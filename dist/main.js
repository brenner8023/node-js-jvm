/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/commander/index.js":
/*!*****************************************!*\
  !*** ./node_modules/commander/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar spawn = __webpack_require__(/*! child_process */ \"child_process\").spawn;\nvar path = __webpack_require__(/*! path */ \"path\");\nvar dirname = path.dirname;\nvar basename = path.basename;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n/**\n * Inherit `Command` from `EventEmitter.prototype`.\n */\n\n__webpack_require__(/*! util */ \"util\").inherits(Command, EventEmitter);\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\n\n/**\n * Expose `Command`.\n */\n\nexports.Command = Command;\n\n/**\n * Expose `Option`.\n */\n\nexports.Option = Option;\n\n/**\n * Initialize a new `Option` with the given `flags` and `description`.\n *\n * @param {String} flags\n * @param {String} description\n * @api public\n */\n\nfunction Option(flags, description) {\n  this.flags = flags;\n  this.required = flags.indexOf('<') >= 0; // A value must be supplied when the option is specified.\n  this.optional = flags.indexOf('[') >= 0; // A value is optional when the option is specified.\n  this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n  this.negate = flags.indexOf('-no-') !== -1;\n  flags = flags.split(/[ ,|]+/);\n  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();\n  this.long = flags.shift();\n  this.description = description || '';\n}\n\n/**\n * Return option name.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.name = function() {\n  return this.long.replace(/^--/, '');\n};\n\n/**\n * Return option name, in a camelcase format that can be used\n * as a object attribute key.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.attributeName = function() {\n  return camelcase(this.name().replace(/^no-/, ''));\n};\n\n/**\n * Check if `arg` matches the short or long flag.\n *\n * @param {String} arg\n * @return {Boolean}\n * @api private\n */\n\nOption.prototype.is = function(arg) {\n  return this.short === arg || this.long === arg;\n};\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {Number} exitCode suggested exit code which could be used with process.exit\n   * @param {String} code an id string representing the error\n   * @param {String} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n  }\n}\n\nexports.CommanderError = CommanderError;\n\n/**\n * Initialize a new `Command`.\n *\n * @param {String} [name]\n * @api public\n */\n\nfunction Command(name) {\n  this.commands = [];\n  this.options = [];\n  this._execs = new Set();\n  this._allowUnknownOption = false;\n  this._args = [];\n  this._name = name || '';\n  this._optionValues = {};\n  this._storeOptionsAsProperties = true; // backwards compatible by default\n  this._passCommandToAction = true; // backwards compatible by default\n  this._actionResults = [];\n\n  this._helpFlags = '-h, --help';\n  this._helpDescription = 'output usage information';\n  this._helpShortFlag = '-h';\n  this._helpLongFlag = '--help';\n}\n\n/**\n * Define a command.\n *\n * There are two styles of command: pay attention to where to put the description.\n *\n * Examples:\n *\n *      // Command implemented using action handler (description is supplied separately to `.command`)\n *      program\n *        .command('clone <source> [destination]')\n *        .description('clone a repository into a newly created directory')\n *        .action((source, destination) => {\n *          console.log('clone command called');\n *        });\n *\n *      // Command implemented using separate executable file (description is second parameter to `.command`)\n *      program\n *        .command('start <service>', 'start named service')\n *        .command('stop [service]', 'stop named service, or all if no name supplied');\n *\n * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n * @param {Object} [execOpts] - configuration options (for executable)\n * @return {Command} returns new command for action handler, or top-level command for executable command\n * @api public\n */\n\nCommand.prototype.command = function(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n  var desc = actionOptsOrExecDesc;\n  var opts = execOpts;\n  if (typeof desc === 'object' && desc !== null) {\n    opts = desc;\n    desc = null;\n  }\n  opts = opts || {};\n  var args = nameAndArgs.split(/ +/);\n  var cmd = new Command(args.shift());\n\n  if (desc) {\n    cmd.description(desc);\n    this.executables = true;\n    this._execs.add(cmd._name);\n    if (opts.isDefault) this.defaultExecutable = cmd._name;\n  }\n  cmd._noHelp = !!opts.noHelp;\n  cmd._helpFlags = this._helpFlags;\n  cmd._helpDescription = this._helpDescription;\n  cmd._helpShortFlag = this._helpShortFlag;\n  cmd._helpLongFlag = this._helpLongFlag;\n  cmd._exitCallback = this._exitCallback;\n  cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;\n  cmd._passCommandToAction = this._passCommandToAction;\n\n  cmd._executableFile = opts.executableFile; // Custom name for executable file\n  this.commands.push(cmd);\n  cmd.parseExpectedArgs(args);\n  cmd.parent = this;\n\n  if (desc) return this;\n  return cmd;\n};\n\n/**\n * Define argument syntax for the top-level command.\n *\n * @api public\n */\n\nCommand.prototype.arguments = function(desc) {\n  return this.parseExpectedArgs(desc.split(/ +/));\n};\n\n/**\n * Add an implicit `help [cmd]` subcommand\n * which invokes `--help` for the given command.\n *\n * @api private\n */\n\nCommand.prototype.addImplicitHelpCommand = function() {\n  this.command('help [cmd]', 'display help for [cmd]');\n};\n\n/**\n * Parse expected `args`.\n *\n * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parseExpectedArgs = function(args) {\n  if (!args.length) return;\n  var self = this;\n  args.forEach(function(arg) {\n    var argDetails = {\n      required: false,\n      name: '',\n      variadic: false\n    };\n\n    switch (arg[0]) {\n      case '<':\n        argDetails.required = true;\n        argDetails.name = arg.slice(1, -1);\n        break;\n      case '[':\n        argDetails.name = arg.slice(1, -1);\n        break;\n    }\n\n    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n      argDetails.variadic = true;\n      argDetails.name = argDetails.name.slice(0, -3);\n    }\n    if (argDetails.name) {\n      self._args.push(argDetails);\n    }\n  });\n  return this;\n};\n\n/**\n * Register callback to use as replacement for calling process.exit.\n *\n * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.exitOverride = function(fn) {\n  if (fn) {\n    this._exitCallback = fn;\n  } else {\n    this._exitCallback = function(err) {\n      if (err.code !== 'commander.executeSubCommandAsync') {\n        throw err;\n      } else {\n        // Async callback from spawn events, not useful to throw.\n      }\n    };\n  }\n  return this;\n};\n\n/**\n * Call process.exit, and _exitCallback if defined.\n *\n * @param {Number} exitCode exit code for using with process.exit\n * @param {String} code an id string representing the error\n * @param {String} message human-readable description of the error\n * @return never\n * @api private\n */\n\nCommand.prototype._exit = function(exitCode, code, message) {\n  if (this._exitCallback) {\n    this._exitCallback(new CommanderError(exitCode, code, message));\n    // Expecting this line is not reached.\n  }\n  process.exit(exitCode);\n};\n\n/**\n * Register callback `fn` for the command.\n *\n * Examples:\n *\n *      program\n *        .command('help')\n *        .description('display verbose help')\n *        .action(function() {\n *           // output help here\n *        });\n *\n * @param {Function} fn\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.action = function(fn) {\n  var self = this;\n  var listener = function(args, unknown) {\n    // Parse any so-far unknown options\n    args = args || [];\n    unknown = unknown || [];\n\n    var parsed = self.parseOptions(unknown);\n\n    // Output help if necessary\n    outputHelpIfRequested(self, parsed.unknown);\n    self._checkForMissingMandatoryOptions();\n\n    // If there are still any unknown options, then we simply\n    // die, unless someone asked for help, in which case we give it\n    // to them, and then we die.\n    if (parsed.unknown.length > 0) {\n      self.unknownOption(parsed.unknown[0]);\n    }\n\n    // Leftover arguments need to be pushed back. Fixes issue #56\n    if (parsed.args.length) args = parsed.args.concat(args);\n\n    self._args.forEach(function(arg, i) {\n      if (arg.required && args[i] == null) {\n        self.missingArgument(arg.name);\n      } else if (arg.variadic) {\n        if (i !== self._args.length - 1) {\n          self.variadicArgNotLast(arg.name);\n        }\n\n        args[i] = args.splice(i);\n      }\n    });\n\n    // The .action callback takes an extra parameter which is the command itself.\n    var expectedArgsCount = self._args.length;\n    var actionArgs = args.slice(0, expectedArgsCount);\n    if (self._passCommandToAction) {\n      actionArgs[expectedArgsCount] = self;\n    } else {\n      actionArgs[expectedArgsCount] = self.opts();\n    }\n    // Add the extra arguments so available too.\n    if (args.length > expectedArgsCount) {\n      actionArgs.push(args.slice(expectedArgsCount));\n    }\n\n    const actionResult = fn.apply(self, actionArgs);\n    // Remember result in case it is async. Assume parseAsync getting called on root.\n    let rootCommand = self;\n    while (rootCommand.parent) {\n      rootCommand = rootCommand.parent;\n    }\n    rootCommand._actionResults.push(actionResult);\n  };\n  var parent = this.parent || this;\n  var name = parent === this ? '*' : this._name;\n  parent.on('command:' + name, listener);\n  if (this._alias) parent.on('command:' + this._alias, listener);\n  return this;\n};\n\n/**\n * Internal implementation shared by .option() and .requiredOption()\n *\n * @param {Object} config\n * @param {String} flags\n * @param {String} description\n * @param {Function|*} [fn] - custom option processing function or default vaue\n * @param {*} [defaultValue]\n * @return {Command} for chaining\n * @api private\n */\n\nCommand.prototype._optionEx = function(config, flags, description, fn, defaultValue) {\n  var self = this,\n    option = new Option(flags, description),\n    oname = option.name(),\n    name = option.attributeName();\n  option.mandatory = !!config.mandatory;\n\n  // default as 3rd arg\n  if (typeof fn !== 'function') {\n    if (fn instanceof RegExp) {\n      // This is a bit simplistic (especially no error messages), and probably better handled by caller using custom option processing.\n      // No longer documented in README, but still present for backwards compatibility.\n      var regex = fn;\n      fn = function(val, def) {\n        var m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n    } else {\n      defaultValue = fn;\n      fn = null;\n    }\n  }\n\n  // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n  if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n    // when --no-foo we make sure default is true, unless a --foo option is already defined\n    if (option.negate) {\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      defaultValue = self.optionFor(positiveLongFlag) ? self._getOptionValue(name) : true;\n    }\n    // preassign only if we have a default\n    if (defaultValue !== undefined) {\n      self._setOptionValue(name, defaultValue);\n      option.defaultValue = defaultValue;\n    }\n  }\n\n  // register the option\n  this.options.push(option);\n\n  // when it's passed assign the value\n  // and conditionally invoke the callback\n  this.on('option:' + oname, function(val) {\n    // coercion\n    if (val !== null && fn) {\n      val = fn(val, self._getOptionValue(name) === undefined ? defaultValue : self._getOptionValue(name));\n    }\n\n    // unassigned or boolean value\n    if (typeof self._getOptionValue(name) === 'boolean' || typeof self._getOptionValue(name) === 'undefined') {\n      // if no value, negate false, and we have a default, then use it!\n      if (val == null) {\n        self._setOptionValue(name, option.negate\n          ? false\n          : defaultValue || true);\n      } else {\n        self._setOptionValue(name, val);\n      }\n    } else if (val !== null) {\n      // reassign\n      self._setOptionValue(name, option.negate ? false : val);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Define option with `flags`, `description` and optional\n * coercion `fn`.\n *\n * The `flags` string should contain both the short and long flags,\n * separated by comma, a pipe or space. The following are all valid\n * all will output this way when `--help` is used.\n *\n *    \"-p, --pepper\"\n *    \"-p|--pepper\"\n *    \"-p --pepper\"\n *\n * Examples:\n *\n *     // simple boolean defaulting to undefined\n *     program.option('-p, --pepper', 'add pepper');\n *\n *     program.pepper\n *     // => undefined\n *\n *     --pepper\n *     program.pepper\n *     // => true\n *\n *     // simple boolean defaulting to true (unless non-negated option is also defined)\n *     program.option('-C, --no-cheese', 'remove cheese');\n *\n *     program.cheese\n *     // => true\n *\n *     --no-cheese\n *     program.cheese\n *     // => false\n *\n *     // required argument\n *     program.option('-C, --chdir <path>', 'change the working directory');\n *\n *     --chdir /tmp\n *     program.chdir\n *     // => \"/tmp\"\n *\n *     // optional argument\n *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function|*} [fn] - custom option processing function or default vaue\n * @param {*} [defaultValue]\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.option = function(flags, description, fn, defaultValue) {\n  return this._optionEx({}, flags, description, fn, defaultValue);\n};\n\n/*\n * Add a required option which must have a value after parsing. This usually means\n * the option must be specified on the command line. (Otherwise the same as .option().)\n *\n * The `flags` string should contain both the short and long flags, separated by comma, a pipe or space.\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function|*} [fn] - custom option processing function or default vaue\n * @param {*} [defaultValue]\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.requiredOption = function(flags, description, fn, defaultValue) {\n  return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n};\n\n/**\n * Allow unknown options on the command line.\n *\n * @param {Boolean} arg if `true` or omitted, no error will be thrown\n * for unknown options.\n * @api public\n */\nCommand.prototype.allowUnknownOption = function(arg) {\n  this._allowUnknownOption = arguments.length === 0 || arg;\n  return this;\n};\n\n/**\n  * Whether to store option values as properties on command object,\n  * or store separately (specify false). In both cases the option values can be accessed using .opts().\n  *\n  * @param {boolean} value\n  * @return {Command} Command for chaining\n  * @api public\n  */\n\nCommand.prototype.storeOptionsAsProperties = function(value) {\n  this._storeOptionsAsProperties = (value === undefined) || value;\n  if (this.options.length) {\n    // This is for programmer, not end user.\n    console.error('Commander usage error: call storeOptionsAsProperties before adding options');\n  }\n  return this;\n};\n\n/**\n  * Whether to pass command to action handler,\n  * or just the options (specify false).\n  *\n  * @param {boolean} value\n  * @return {Command} Command for chaining\n  * @api public\n  */\n\nCommand.prototype.passCommandToAction = function(value) {\n  this._passCommandToAction = (value === undefined) || value;\n  return this;\n};\n\n/**\n * Store option value\n *\n * @param {String} key\n * @param {Object} value\n * @api private\n */\n\nCommand.prototype._setOptionValue = function(key, value) {\n  if (this._storeOptionsAsProperties) {\n    this[key] = value;\n  } else {\n    this._optionValues[key] = value;\n  }\n};\n\n/**\n * Retrieve option value\n *\n * @param {String} key\n * @return {Object} value\n * @api private\n */\n\nCommand.prototype._getOptionValue = function(key) {\n  if (this._storeOptionsAsProperties) {\n    return this[key];\n  }\n  return this._optionValues[key];\n};\n\n/**\n * Parse `argv`, setting options and invoking commands when defined.\n *\n * @param {Array} argv\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parse = function(argv) {\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], '.js');\n\n  // github-style sub-commands with no sub-command\n  if (this.executables && argv.length < 3 && !this.defaultExecutable) {\n    // this user needs help\n    argv.push(this._helpLongFlag);\n  }\n\n  // process argv\n  var normalized = this.normalize(argv.slice(2));\n  var parsed = this.parseOptions(normalized);\n  var args = this.args = parsed.args;\n\n  var result = this.parseArgs(this.args, parsed.unknown);\n\n  if (args[0] === 'help' && args.length === 1) this.help();\n\n  // Note for future: we could return early if we found an action handler in parseArgs, as none of following code needed?\n\n  // <cmd> --help\n  if (args[0] === 'help') {\n    args[0] = args[1];\n    args[1] = this._helpLongFlag;\n  } else {\n    // If calling through to executable subcommand we could check for help flags before failing,\n    // but a somewhat unlikely case since program options not passed to executable subcommands.\n    // Wait for reports to see if check needed and what usage pattern is.\n    this._checkForMissingMandatoryOptions();\n  }\n\n  // executable sub-commands\n  // (Debugging note for future: args[0] is not right if an action has been called)\n  var name = result.args[0];\n  var subCommand = null;\n\n  // Look for subcommand\n  if (name) {\n    subCommand = this.commands.find(function(command) {\n      return command._name === name;\n    });\n  }\n\n  // Look for alias\n  if (!subCommand && name) {\n    subCommand = this.commands.find(function(command) {\n      return command.alias() === name;\n    });\n    if (subCommand) {\n      name = subCommand._name;\n      args[0] = name;\n    }\n  }\n\n  // Look for default subcommand\n  if (!subCommand && this.defaultExecutable) {\n    name = this.defaultExecutable;\n    args.unshift(name);\n    subCommand = this.commands.find(function(command) {\n      return command._name === name;\n    });\n  }\n\n  if (this._execs.has(name)) {\n    return this.executeSubCommand(argv, args, parsed.unknown, subCommand ? subCommand._executableFile : undefined);\n  }\n\n  return result;\n};\n\n/**\n * Parse `argv`, setting options and invoking commands when defined.\n *\n * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n *\n * @param {Array} argv\n * @return {Promise}\n * @api public\n */\nCommand.prototype.parseAsync = function(argv) {\n  this.parse(argv);\n  return Promise.all(this._actionResults);\n};\n\n/**\n * Execute a sub-command executable.\n *\n * @param {Array} argv\n * @param {Array} args\n * @param {Array} unknown\n * @param {String} executableFile\n * @api private\n */\n\nCommand.prototype.executeSubCommand = function(argv, args, unknown, executableFile) {\n  args = args.concat(unknown);\n\n  if (!args.length) this.help();\n\n  var isExplicitJS = false; // Whether to use node to launch \"executable\"\n\n  // executable\n  var pm = argv[1];\n  // name of the subcommand, like `pm-install`\n  var bin = basename(pm, path.extname(pm)) + '-' + args[0];\n  if (executableFile != null) {\n    bin = executableFile;\n    // Check for same extensions as we scan for below so get consistent launch behaviour.\n    var executableExt = path.extname(executableFile);\n    isExplicitJS = executableExt === '.js' || executableExt === '.ts' || executableExt === '.mjs';\n  }\n\n  // In case of globally installed, get the base dir where executable\n  //  subcommand file should be located at\n  var baseDir;\n\n  var resolvedLink = fs.realpathSync(pm);\n\n  baseDir = dirname(resolvedLink);\n\n  // prefer local `./<bin>` to bin in the $PATH\n  var localBin = path.join(baseDir, bin);\n\n  // whether bin file is a js script with explicit `.js` or `.ts` extension\n  if (exists(localBin + '.js')) {\n    bin = localBin + '.js';\n    isExplicitJS = true;\n  } else if (exists(localBin + '.ts')) {\n    bin = localBin + '.ts';\n    isExplicitJS = true;\n  } else if (exists(localBin + '.mjs')) {\n    bin = localBin + '.mjs';\n    isExplicitJS = true;\n  } else if (exists(localBin)) {\n    bin = localBin;\n  }\n\n  args = args.slice(1);\n\n  var proc;\n  if (process.platform !== 'win32') {\n    if (isExplicitJS) {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n      proc = spawn(process.argv[0], args, { stdio: 'inherit' });\n    } else {\n      proc = spawn(bin, args, { stdio: 'inherit' });\n    }\n  } else {\n    args.unshift(bin);\n    // add executable arguments to spawn\n    args = incrementNodeInspectorPort(process.execArgv).concat(args);\n    proc = spawn(process.execPath, args, { stdio: 'inherit' });\n  }\n\n  var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n  signals.forEach(function(signal) {\n    process.on(signal, function() {\n      if (proc.killed === false && proc.exitCode === null) {\n        proc.kill(signal);\n      }\n    });\n  });\n\n  // By default terminate process when spawned process terminates.\n  // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n  const exitCallback = this._exitCallback;\n  if (!exitCallback) {\n    proc.on('close', process.exit.bind(process));\n  } else {\n    proc.on('close', () => {\n      exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n    });\n  }\n  proc.on('error', function(err) {\n    if (err.code === 'ENOENT') {\n      console.error('error: %s(1) does not exist, try --help', bin);\n    } else if (err.code === 'EACCES') {\n      console.error('error: %s(1) not executable. try chmod or run with root', bin);\n    }\n    if (!exitCallback) {\n      process.exit(1);\n    } else {\n      const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n      wrappedError.nestedError = err;\n      exitCallback(wrappedError);\n    }\n  });\n\n  // Store the reference to the child process\n  this.runningCommand = proc;\n};\n\n/**\n * Normalize `args`, splitting joined short flags. For example\n * the arg \"-abc\" is equivalent to \"-a -b -c\".\n * This also normalizes equal sign and splits \"--abc=def\" into \"--abc def\".\n *\n * @param {Array} args\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.normalize = function(args) {\n  var ret = [],\n    arg,\n    lastOpt,\n    index,\n    short,\n    opt;\n\n  for (var i = 0, len = args.length; i < len; ++i) {\n    arg = args[i];\n    if (i > 0) {\n      lastOpt = this.optionFor(args[i - 1]);\n    }\n\n    if (arg === '--') {\n      // Honor option terminator\n      ret = ret.concat(args.slice(i));\n      break;\n    } else if (lastOpt && lastOpt.required) {\n      ret.push(arg);\n    } else if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n      short = arg.slice(0, 2);\n      opt = this.optionFor(short);\n      if (opt && (opt.required || opt.optional)) {\n        ret.push(short);\n        ret.push(arg.slice(2));\n      } else {\n        arg.slice(1).split('').forEach(function(c) {\n          ret.push('-' + c);\n        });\n      }\n    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {\n      ret.push(arg.slice(0, index), arg.slice(index + 1));\n    } else {\n      ret.push(arg);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parse command `args`.\n *\n * When listener(s) are available those\n * callbacks are invoked, otherwise the \"*\"\n * event is emitted and those actions are invoked.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api private\n */\n\nCommand.prototype.parseArgs = function(args, unknown) {\n  var name;\n\n  if (args.length) {\n    name = args[0];\n    if (this.listeners('command:' + name).length) {\n      this.emit('command:' + args.shift(), args, unknown);\n    } else {\n      this.emit('command:*', args, unknown);\n    }\n  } else {\n    outputHelpIfRequested(this, unknown);\n\n    // If there were no args and we have unknown options,\n    // then they are extraneous and we need to error.\n    if (unknown.length > 0 && !this.defaultExecutable) {\n      this.unknownOption(unknown[0]);\n    }\n    if (this.commands.length === 0 &&\n        this._args.filter(function(a) { return a.required; }).length === 0) {\n      this.emit('command:*');\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an option matching `arg` if any.\n *\n * @param {String} arg\n * @return {Option}\n * @api private\n */\n\nCommand.prototype.optionFor = function(arg) {\n  for (var i = 0, len = this.options.length; i < len; ++i) {\n    if (this.options[i].is(arg)) {\n      return this.options[i];\n    }\n  }\n};\n\n/**\n * Display an error message if a mandatory option does not have a value.\n *\n * @api private\n */\n\nCommand.prototype._checkForMissingMandatoryOptions = function() {\n  // Walk up hierarchy so can call from action handler after checking for displaying help.\n  for (var cmd = this; cmd; cmd = cmd.parent) {\n    cmd.options.forEach((anOption) => {\n      if (anOption.mandatory && (cmd._getOptionValue(anOption.attributeName()) === undefined)) {\n        cmd.missingMandatoryOptionValue(anOption);\n      }\n    });\n  }\n};\n\n/**\n * Parse options from `argv` returning `argv`\n * void of these options.\n *\n * @param {Array} argv\n * @return {{args: Array, unknown: Array}}\n * @api public\n */\n\nCommand.prototype.parseOptions = function(argv) {\n  var args = [],\n    len = argv.length,\n    literal,\n    option,\n    arg;\n\n  var unknownOptions = [];\n\n  // parse options\n  for (var i = 0; i < len; ++i) {\n    arg = argv[i];\n\n    // literal args after --\n    if (literal) {\n      args.push(arg);\n      continue;\n    }\n\n    if (arg === '--') {\n      literal = true;\n      continue;\n    }\n\n    // find matching Option\n    option = this.optionFor(arg);\n\n    // option is defined\n    if (option) {\n      // requires arg\n      if (option.required) {\n        arg = argv[++i];\n        if (arg == null) return this.optionMissingArgument(option);\n        this.emit('option:' + option.name(), arg);\n      // optional arg\n      } else if (option.optional) {\n        arg = argv[i + 1];\n        if (arg == null || (arg[0] === '-' && arg !== '-')) {\n          arg = null;\n        } else {\n          ++i;\n        }\n        this.emit('option:' + option.name(), arg);\n      // flag\n      } else {\n        this.emit('option:' + option.name());\n      }\n      continue;\n    }\n\n    // looks like an option\n    if (arg.length > 1 && arg[0] === '-') {\n      unknownOptions.push(arg);\n\n      // If the next argument looks like it might be\n      // an argument for this option, we pass it on.\n      // If it isn't, then it'll simply be ignored\n      if ((i + 1) < argv.length && (argv[i + 1][0] !== '-' || argv[i + 1] === '-')) {\n        unknownOptions.push(argv[++i]);\n      }\n      continue;\n    }\n\n    // arg\n    args.push(arg);\n  }\n\n  return { args: args, unknown: unknownOptions };\n};\n\n/**\n * Return an object containing options as key-value pairs\n *\n * @return {Object}\n * @api public\n */\nCommand.prototype.opts = function() {\n  if (this._storeOptionsAsProperties) {\n    // Preserve original behaviour so backwards compatible when still using properties\n    var result = {},\n      len = this.options.length;\n\n    for (var i = 0; i < len; i++) {\n      var key = this.options[i].attributeName();\n      result[key] = key === this._versionOptionName ? this._version : this[key];\n    }\n    return result;\n  }\n\n  return this._optionValues;\n};\n\n/**\n * Argument `name` is missing.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.missingArgument = function(name) {\n  const message = `error: missing required argument '${name}'`;\n  console.error(message);\n  this._exit(1, 'commander.missingArgument', message);\n};\n\n/**\n * `Option` is missing an argument, but received `flag` or nothing.\n *\n * @param {Option} option\n * @param {String} [flag]\n * @api private\n */\n\nCommand.prototype.optionMissingArgument = function(option, flag) {\n  let message;\n  if (flag) {\n    message = `error: option '${option.flags}' argument missing, got '${flag}'`;\n  } else {\n    message = `error: option '${option.flags}' argument missing`;\n  }\n  console.error(message);\n  this._exit(1, 'commander.optionMissingArgument', message);\n};\n\n/**\n * `Option` does not have a value, and is a mandatory option.\n *\n * @param {Option} option\n * @api private\n */\n\nCommand.prototype.missingMandatoryOptionValue = function(option) {\n  const message = `error: required option '${option.flags}' not specified`;\n  console.error(message);\n  this._exit(1, 'commander.missingMandatoryOptionValue', message);\n};\n\n/**\n * Unknown option `flag`.\n *\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.unknownOption = function(flag) {\n  if (this._allowUnknownOption) return;\n  const message = `error: unknown option '${flag}'`;\n  console.error(message);\n  this._exit(1, 'commander.unknownOption', message);\n};\n\n/**\n * Variadic argument with `name` is not the last argument as required.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.variadicArgNotLast = function(name) {\n  const message = `error: variadic arguments must be last '${name}'`;\n  console.error(message);\n  this._exit(1, 'commander.variadicArgNotLast', message);\n};\n\n/**\n * Set the program version to `str`.\n *\n * This method auto-registers the \"-V, --version\" flag\n * which will print the version number when passed.\n *\n * You can optionally supply the  flags and description to override the defaults.\n *\n * @param {String} str\n * @param {String} [flags]\n * @param {String} [description]\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.version = function(str, flags, description) {\n  if (arguments.length === 0) return this._version;\n  this._version = str;\n  flags = flags || '-V, --version';\n  description = description || 'output the version number';\n  var versionOption = new Option(flags, description);\n  this._versionOptionName = versionOption.long.substr(2) || 'version';\n  this.options.push(versionOption);\n  var self = this;\n  this.on('option:' + this._versionOptionName, function() {\n    process.stdout.write(str + '\\n');\n    self._exit(0, 'commander.version', str);\n  });\n  return this;\n};\n\n/**\n * Set the description to `str`.\n *\n * @param {String} str\n * @param {Object} [argsDescription]\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.description = function(str, argsDescription) {\n  if (arguments.length === 0) return this._description;\n  this._description = str;\n  this._argsDescription = argsDescription;\n  return this;\n};\n\n/**\n * Set an alias for the command\n *\n * @param {String} alias\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.alias = function(alias) {\n  var command = this;\n  if (this.commands.length !== 0) {\n    command = this.commands[this.commands.length - 1];\n  }\n\n  if (arguments.length === 0) return command._alias;\n\n  if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n  command._alias = alias;\n  return this;\n};\n\n/**\n * Set / get the command usage `str`.\n *\n * @param {String} [str]\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.usage = function(str) {\n  var args = this._args.map(function(arg) {\n    return humanReadableArgName(arg);\n  });\n\n  var usage = '[options]' +\n    (this.commands.length ? ' [command]' : '') +\n    (this._args.length ? ' ' + args.join(' ') : '');\n\n  if (arguments.length === 0) return this._usage || usage;\n  this._usage = str;\n\n  return this;\n};\n\n/**\n * Get or set the name of the command\n *\n * @param {String} [str]\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.name = function(str) {\n  if (arguments.length === 0) return this._name;\n  this._name = str;\n  return this;\n};\n\n/**\n * Return prepared commands.\n *\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.prepareCommands = function() {\n  return this.commands.filter(function(cmd) {\n    return !cmd._noHelp;\n  }).map(function(cmd) {\n    var args = cmd._args.map(function(arg) {\n      return humanReadableArgName(arg);\n    }).join(' ');\n\n    return [\n      cmd._name +\n        (cmd._alias ? '|' + cmd._alias : '') +\n        (cmd.options.length ? ' [options]' : '') +\n        (args ? ' ' + args : ''),\n      cmd._description\n    ];\n  });\n};\n\n/**\n * Return the largest command length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestCommandLength = function() {\n  var commands = this.prepareCommands();\n  return commands.reduce(function(max, command) {\n    return Math.max(max, command[0].length);\n  }, 0);\n};\n\n/**\n * Return the largest option length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestOptionLength = function() {\n  var options = [].slice.call(this.options);\n  options.push({\n    flags: this._helpFlags\n  });\n\n  return options.reduce(function(max, option) {\n    return Math.max(max, option.flags.length);\n  }, 0);\n};\n\n/**\n * Return the largest arg length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestArgLength = function() {\n  return this._args.reduce(function(max, arg) {\n    return Math.max(max, arg.name.length);\n  }, 0);\n};\n\n/**\n * Return the pad width.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.padWidth = function() {\n  var width = this.largestOptionLength();\n  if (this._argsDescription && this._args.length) {\n    if (this.largestArgLength() > width) {\n      width = this.largestArgLength();\n    }\n  }\n\n  if (this.commands && this.commands.length) {\n    if (this.largestCommandLength() > width) {\n      width = this.largestCommandLength();\n    }\n  }\n\n  return width;\n};\n\n/**\n * Return help for options.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.optionHelp = function() {\n  var width = this.padWidth();\n\n  var columns = process.stdout.columns || 80;\n  var descriptionWidth = columns - width - 4;\n\n  // Append the help information\n  return this.options.map(function(option) {\n    const fullDesc = option.description +\n      ((!option.negate && option.defaultValue !== undefined) ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');\n    return pad(option.flags, width) + '  ' + optionalWrap(fullDesc, descriptionWidth, width + 2);\n  }).concat([pad(this._helpFlags, width) + '  ' + optionalWrap(this._helpDescription, descriptionWidth, width + 2)])\n    .join('\\n');\n};\n\n/**\n * Return command help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.commandHelp = function() {\n  if (!this.commands.length) return '';\n\n  var commands = this.prepareCommands();\n  var width = this.padWidth();\n\n  var columns = process.stdout.columns || 80;\n  var descriptionWidth = columns - width - 4;\n\n  return [\n    'Commands:',\n    commands.map(function(cmd) {\n      var desc = cmd[1] ? '  ' + cmd[1] : '';\n      return (desc ? pad(cmd[0], width) : cmd[0]) + optionalWrap(desc, descriptionWidth, width + 2);\n    }).join('\\n').replace(/^/gm, '  '),\n    ''\n  ].join('\\n');\n};\n\n/**\n * Return program help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.helpInformation = function() {\n  var desc = [];\n  if (this._description) {\n    desc = [\n      this._description,\n      ''\n    ];\n\n    var argsDescription = this._argsDescription;\n    if (argsDescription && this._args.length) {\n      var width = this.padWidth();\n      var columns = process.stdout.columns || 80;\n      var descriptionWidth = columns - width - 5;\n      desc.push('Arguments:');\n      desc.push('');\n      this._args.forEach(function(arg) {\n        desc.push('  ' + pad(arg.name, width) + '  ' + wrap(argsDescription[arg.name], descriptionWidth, width + 4));\n      });\n      desc.push('');\n    }\n  }\n\n  var cmdName = this._name;\n  if (this._alias) {\n    cmdName = cmdName + '|' + this._alias;\n  }\n  var parentCmdNames = '';\n  for (var parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n    parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n  }\n  var usage = [\n    'Usage: ' + parentCmdNames + cmdName + ' ' + this.usage(),\n    ''\n  ];\n\n  var cmds = [];\n  var commandHelp = this.commandHelp();\n  if (commandHelp) cmds = [commandHelp];\n\n  var options = [\n    'Options:',\n    '' + this.optionHelp().replace(/^/gm, '  '),\n    ''\n  ];\n\n  return usage\n    .concat(desc)\n    .concat(options)\n    .concat(cmds)\n    .join('\\n');\n};\n\n/**\n * Output help information for this command.\n *\n * When listener(s) are available for the helpLongFlag\n * those callbacks are invoked.\n *\n * @api public\n */\n\nCommand.prototype.outputHelp = function(cb) {\n  if (!cb) {\n    cb = function(passthru) {\n      return passthru;\n    };\n  }\n  const cbOutput = cb(this.helpInformation());\n  if (typeof cbOutput !== 'string' && !Buffer.isBuffer(cbOutput)) {\n    throw new Error('outputHelp callback must return a string or a Buffer');\n  }\n  process.stdout.write(cbOutput);\n  this.emit(this._helpLongFlag);\n};\n\n/**\n * You can pass in flags and a description to override the help\n * flags and help description for your command.\n *\n * @param {String} [flags]\n * @param {String} [description]\n * @return {Command}\n * @api public\n */\n\nCommand.prototype.helpOption = function(flags, description) {\n  this._helpFlags = flags || this._helpFlags;\n  this._helpDescription = description || this._helpDescription;\n\n  var splitFlags = this._helpFlags.split(/[ ,|]+/);\n\n  if (splitFlags.length > 1) this._helpShortFlag = splitFlags.shift();\n\n  this._helpLongFlag = splitFlags.shift();\n\n  return this;\n};\n\n/**\n * Output help information and exit.\n *\n * @param {Function} [cb]\n * @api public\n */\n\nCommand.prototype.help = function(cb) {\n  this.outputHelp(cb);\n  // exitCode: preserving original behaviour which was calling process.exit()\n  // message: do not have all displayed text available so only passing placeholder.\n  this._exit(process.exitCode || 0, 'commander.help', '(outputHelp)');\n};\n\n/**\n * Camel-case the given `flag`\n *\n * @param {String} flag\n * @return {String}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce(function(str, word) {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Pad `str` to `width`.\n *\n * @param {String} str\n * @param {Number} width\n * @return {String}\n * @api private\n */\n\nfunction pad(str, width) {\n  var len = Math.max(0, width - str.length);\n  return str + Array(len + 1).join(' ');\n}\n\n/**\n * Wraps the given string with line breaks at the specified width while breaking\n * words and indenting every but the first line on the left.\n *\n * @param {String} str\n * @param {Number} width\n * @param {Number} indent\n * @return {String}\n * @api private\n */\nfunction wrap(str, width, indent) {\n  var regex = new RegExp('.{1,' + (width - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n  var lines = str.match(regex) || [];\n  return lines.map(function(line, i) {\n    if (line.slice(-1) === '\\n') {\n      line = line.slice(0, line.length - 1);\n    }\n    return ((i > 0 && indent) ? Array(indent + 1).join(' ') : '') + line.trimRight();\n  }).join('\\n');\n}\n\n/**\n * Optionally wrap the given str to a max width of width characters per line\n * while indenting with indent spaces. Do not wrap if insufficient width or\n * string is manually formatted.\n *\n * @param {String} str\n * @param {Number} width\n * @param {Number} indent\n * @return {String}\n * @api private\n */\nfunction optionalWrap(str, width, indent) {\n  // Detect manually wrapped and indented strings by searching for line breaks\n  // followed by multiple spaces/tabs.\n  if (str.match(/[\\n]\\s+/)) return str;\n  // Do not wrap to narrow columns (or can end up with a word per line).\n  const minWidth = 40;\n  if (width < minWidth) return str;\n\n  return wrap(str, width, indent);\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} options - array of options to search for -h or --help\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, options) {\n  options = options || [];\n\n  for (var i = 0; i < options.length; i++) {\n    if (options[i] === cmd._helpLongFlag || options[i] === cmd._helpShortFlag) {\n      cmd.outputHelp();\n      // (Do not have all displayed text available so only passing placeholder.)\n      cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n    }\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {String}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\n// for versions before node v0.8 when there weren't `fs.existsSync`\nfunction exists(file) {\n  try {\n    if (fs.statSync(file).isFile()) {\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    var result = arg;\n    if (arg.indexOf('--inspect') === 0) {\n      var debugOption;\n      var debugHost = '127.0.0.1';\n      var debugPort = '9229';\n      var match;\n      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n        // e.g. --inspect\n        debugOption = match[1];\n      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n        debugOption = match[1];\n        if (/^\\d+$/.test(match[3])) {\n          // e.g. --inspect=1234\n          debugPort = match[3];\n        } else {\n          // e.g. --inspect=localhost\n          debugHost = match[3];\n        }\n      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n        // e.g. --inspect=localhost:1234\n        debugOption = match[1];\n        debugHost = match[3];\n        debugPort = match[4];\n      }\n\n      if (debugOption && debugPort !== '0') {\n        result = `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n      }\n    }\n    return result;\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbWFuZGVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1hbmRlci9pbmRleC5qcz9hMmEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZGlybmFtZSA9IHBhdGguZGlybmFtZTtcbnZhciBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWU7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG4vKipcbiAqIEluaGVyaXQgYENvbW1hbmRgIGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxuICovXG5cbnJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cyhDb21tYW5kLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgcm9vdCBjb21tYW5kLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBDb21tYW5kKCk7XG5cbi8qKlxuICogRXhwb3NlIGBDb21tYW5kYC5cbiAqL1xuXG5leHBvcnRzLkNvbW1hbmQgPSBDb21tYW5kO1xuXG4vKipcbiAqIEV4cG9zZSBgT3B0aW9uYC5cbiAqL1xuXG5leHBvcnRzLk9wdGlvbiA9IE9wdGlvbjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBPcHRpb25gIHdpdGggdGhlIGdpdmVuIGBmbGFnc2AgYW5kIGBkZXNjcmlwdGlvbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbikge1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIHRoaXMucmVxdWlyZWQgPSBmbGFncy5pbmRleE9mKCc8JykgPj0gMDsgLy8gQSB2YWx1ZSBtdXN0IGJlIHN1cHBsaWVkIHdoZW4gdGhlIG9wdGlvbiBpcyBzcGVjaWZpZWQuXG4gIHRoaXMub3B0aW9uYWwgPSBmbGFncy5pbmRleE9mKCdbJykgPj0gMDsgLy8gQSB2YWx1ZSBpcyBvcHRpb25hbCB3aGVuIHRoZSBvcHRpb24gaXMgc3BlY2lmaWVkLlxuICB0aGlzLm1hbmRhdG9yeSA9IGZhbHNlOyAvLyBUaGUgb3B0aW9uIG11c3QgaGF2ZSBhIHZhbHVlIGFmdGVyIHBhcnNpbmcsIHdoaWNoIHVzdWFsbHkgbWVhbnMgaXQgbXVzdCBiZSBzcGVjaWZpZWQgb24gY29tbWFuZCBsaW5lLlxuICB0aGlzLm5lZ2F0ZSA9IGZsYWdzLmluZGV4T2YoJy1uby0nKSAhPT0gLTE7XG4gIGZsYWdzID0gZmxhZ3Muc3BsaXQoL1sgLHxdKy8pO1xuICBpZiAoZmxhZ3MubGVuZ3RoID4gMSAmJiAhL15bWzxdLy50ZXN0KGZsYWdzWzFdKSkgdGhpcy5zaG9ydCA9IGZsYWdzLnNoaWZ0KCk7XG4gIHRoaXMubG9uZyA9IGZsYWdzLnNoaWZ0KCk7XG4gIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCAnJztcbn1cblxuLyoqXG4gKiBSZXR1cm4gb3B0aW9uIG5hbWUuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT3B0aW9uLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxvbmcucmVwbGFjZSgvXi0tLywgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3B0aW9uIG5hbWUsIGluIGEgY2FtZWxjYXNlIGZvcm1hdCB0aGF0IGNhbiBiZSB1c2VkXG4gKiBhcyBhIG9iamVjdCBhdHRyaWJ1dGUga2V5LlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9wdGlvbi5wcm90b3R5cGUuYXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY2FtZWxjYXNlKHRoaXMubmFtZSgpLnJlcGxhY2UoL15uby0vLCAnJykpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgYXJnYCBtYXRjaGVzIHRoZSBzaG9ydCBvciBsb25nIGZsYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9wdGlvbi5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRoaXMuc2hvcnQgPT09IGFyZyB8fCB0aGlzLmxvbmcgPT09IGFyZztcbn07XG5cbi8qKlxuICogQ29tbWFuZGVyRXJyb3IgY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDb21tYW5kZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIENvbW1hbmRlckVycm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleGl0Q29kZSBzdWdnZXN0ZWQgZXhpdCBjb2RlIHdoaWNoIGNvdWxkIGJlIHVzZWQgd2l0aCBwcm9jZXNzLmV4aXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgYW4gaWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXJyb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoZXhpdENvZGUsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBwcm9wZXJseSBjYXB0dXJlIHN0YWNrIHRyYWNlIGluIE5vZGUuanNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmV4aXRDb2RlID0gZXhpdENvZGU7XG4gIH1cbn1cblxuZXhwb3J0cy5Db21tYW5kZXJFcnJvciA9IENvbW1hbmRlckVycm9yO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbW1hbmRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQ29tbWFuZChuYW1lKSB7XG4gIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gW107XG4gIHRoaXMuX2V4ZWNzID0gbmV3IFNldCgpO1xuICB0aGlzLl9hbGxvd1Vua25vd25PcHRpb24gPSBmYWxzZTtcbiAgdGhpcy5fYXJncyA9IFtdO1xuICB0aGlzLl9uYW1lID0gbmFtZSB8fCAnJztcbiAgdGhpcy5fb3B0aW9uVmFsdWVzID0ge307XG4gIHRoaXMuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcyA9IHRydWU7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIGJ5IGRlZmF1bHRcbiAgdGhpcy5fcGFzc0NvbW1hbmRUb0FjdGlvbiA9IHRydWU7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIGJ5IGRlZmF1bHRcbiAgdGhpcy5fYWN0aW9uUmVzdWx0cyA9IFtdO1xuXG4gIHRoaXMuX2hlbHBGbGFncyA9ICctaCwgLS1oZWxwJztcbiAgdGhpcy5faGVscERlc2NyaXB0aW9uID0gJ291dHB1dCB1c2FnZSBpbmZvcm1hdGlvbic7XG4gIHRoaXMuX2hlbHBTaG9ydEZsYWcgPSAnLWgnO1xuICB0aGlzLl9oZWxwTG9uZ0ZsYWcgPSAnLS1oZWxwJztcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBjb21tYW5kLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gc3R5bGVzIG9mIGNvbW1hbmQ6IHBheSBhdHRlbnRpb24gdG8gd2hlcmUgdG8gcHV0IHRoZSBkZXNjcmlwdGlvbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIC8vIENvbW1hbmQgaW1wbGVtZW50ZWQgdXNpbmcgYWN0aW9uIGhhbmRsZXIgKGRlc2NyaXB0aW9uIGlzIHN1cHBsaWVkIHNlcGFyYXRlbHkgdG8gYC5jb21tYW5kYClcbiAqICAgICAgcHJvZ3JhbVxuICogICAgICAgIC5jb21tYW5kKCdjbG9uZSA8c291cmNlPiBbZGVzdGluYXRpb25dJylcbiAqICAgICAgICAuZGVzY3JpcHRpb24oJ2Nsb25lIGEgcmVwb3NpdG9yeSBpbnRvIGEgbmV3bHkgY3JlYXRlZCBkaXJlY3RvcnknKVxuICogICAgICAgIC5hY3Rpb24oKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdjbG9uZSBjb21tYW5kIGNhbGxlZCcpO1xuICogICAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gQ29tbWFuZCBpbXBsZW1lbnRlZCB1c2luZyBzZXBhcmF0ZSBleGVjdXRhYmxlIGZpbGUgKGRlc2NyaXB0aW9uIGlzIHNlY29uZCBwYXJhbWV0ZXIgdG8gYC5jb21tYW5kYClcbiAqICAgICAgcHJvZ3JhbVxuICogICAgICAgIC5jb21tYW5kKCdzdGFydCA8c2VydmljZT4nLCAnc3RhcnQgbmFtZWQgc2VydmljZScpXG4gKiAgICAgICAgLmNvbW1hbmQoJ3N0b3AgW3NlcnZpY2VdJywgJ3N0b3AgbmFtZWQgc2VydmljZSwgb3IgYWxsIGlmIG5vIG5hbWUgc3VwcGxpZWQnKTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZUFuZEFyZ3MgLSBjb21tYW5kIG5hbWUgYW5kIGFyZ3VtZW50cywgYXJncyBhcmUgYDxyZXF1aXJlZD5gIG9yIGBbb3B0aW9uYWxdYCBhbmQgbGFzdCBtYXkgYWxzbyBiZSBgdmFyaWFkaWMuLi5gXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFthY3Rpb25PcHRzT3JFeGVjRGVzY10gLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgKGZvciBhY3Rpb24pLCBvciBkZXNjcmlwdGlvbiAoZm9yIGV4ZWN1dGFibGUpXG4gKiBAcGFyYW0ge09iamVjdH0gW2V4ZWNPcHRzXSAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAoZm9yIGV4ZWN1dGFibGUpXG4gKiBAcmV0dXJuIHtDb21tYW5kfSByZXR1cm5zIG5ldyBjb21tYW5kIGZvciBhY3Rpb24gaGFuZGxlciwgb3IgdG9wLWxldmVsIGNvbW1hbmQgZm9yIGV4ZWN1dGFibGUgY29tbWFuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24obmFtZUFuZEFyZ3MsIGFjdGlvbk9wdHNPckV4ZWNEZXNjLCBleGVjT3B0cykge1xuICB2YXIgZGVzYyA9IGFjdGlvbk9wdHNPckV4ZWNEZXNjO1xuICB2YXIgb3B0cyA9IGV4ZWNPcHRzO1xuICBpZiAodHlwZW9mIGRlc2MgPT09ICdvYmplY3QnICYmIGRlc2MgIT09IG51bGwpIHtcbiAgICBvcHRzID0gZGVzYztcbiAgICBkZXNjID0gbnVsbDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBuYW1lQW5kQXJncy5zcGxpdCgvICsvKTtcbiAgdmFyIGNtZCA9IG5ldyBDb21tYW5kKGFyZ3Muc2hpZnQoKSk7XG5cbiAgaWYgKGRlc2MpIHtcbiAgICBjbWQuZGVzY3JpcHRpb24oZGVzYyk7XG4gICAgdGhpcy5leGVjdXRhYmxlcyA9IHRydWU7XG4gICAgdGhpcy5fZXhlY3MuYWRkKGNtZC5fbmFtZSk7XG4gICAgaWYgKG9wdHMuaXNEZWZhdWx0KSB0aGlzLmRlZmF1bHRFeGVjdXRhYmxlID0gY21kLl9uYW1lO1xuICB9XG4gIGNtZC5fbm9IZWxwID0gISFvcHRzLm5vSGVscDtcbiAgY21kLl9oZWxwRmxhZ3MgPSB0aGlzLl9oZWxwRmxhZ3M7XG4gIGNtZC5faGVscERlc2NyaXB0aW9uID0gdGhpcy5faGVscERlc2NyaXB0aW9uO1xuICBjbWQuX2hlbHBTaG9ydEZsYWcgPSB0aGlzLl9oZWxwU2hvcnRGbGFnO1xuICBjbWQuX2hlbHBMb25nRmxhZyA9IHRoaXMuX2hlbHBMb25nRmxhZztcbiAgY21kLl9leGl0Q2FsbGJhY2sgPSB0aGlzLl9leGl0Q2FsbGJhY2s7XG4gIGNtZC5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzID0gdGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzO1xuICBjbWQuX3Bhc3NDb21tYW5kVG9BY3Rpb24gPSB0aGlzLl9wYXNzQ29tbWFuZFRvQWN0aW9uO1xuXG4gIGNtZC5fZXhlY3V0YWJsZUZpbGUgPSBvcHRzLmV4ZWN1dGFibGVGaWxlOyAvLyBDdXN0b20gbmFtZSBmb3IgZXhlY3V0YWJsZSBmaWxlXG4gIHRoaXMuY29tbWFuZHMucHVzaChjbWQpO1xuICBjbWQucGFyc2VFeHBlY3RlZEFyZ3MoYXJncyk7XG4gIGNtZC5wYXJlbnQgPSB0aGlzO1xuXG4gIGlmIChkZXNjKSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIGNtZDtcbn07XG5cbi8qKlxuICogRGVmaW5lIGFyZ3VtZW50IHN5bnRheCBmb3IgdGhlIHRvcC1sZXZlbCBjb21tYW5kLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuYXJndW1lbnRzID0gZnVuY3Rpb24oZGVzYykge1xuICByZXR1cm4gdGhpcy5wYXJzZUV4cGVjdGVkQXJncyhkZXNjLnNwbGl0KC8gKy8pKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGltcGxpY2l0IGBoZWxwIFtjbWRdYCBzdWJjb21tYW5kXG4gKiB3aGljaCBpbnZva2VzIGAtLWhlbHBgIGZvciB0aGUgZ2l2ZW4gY29tbWFuZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5hZGRJbXBsaWNpdEhlbHBDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29tbWFuZCgnaGVscCBbY21kXScsICdkaXNwbGF5IGhlbHAgZm9yIFtjbWRdJyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGV4cGVjdGVkIGBhcmdzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgW1wiW3R5cGVdXCJdYCBiZWNvbWVzIGBbeyByZXF1aXJlZDogZmFsc2UsIG5hbWU6ICd0eXBlJyB9XWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnBhcnNlRXhwZWN0ZWRBcmdzID0gZnVuY3Rpb24oYXJncykge1xuICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZykge1xuICAgIHZhciBhcmdEZXRhaWxzID0ge1xuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgbmFtZTogJycsXG4gICAgICB2YXJpYWRpYzogZmFsc2VcbiAgICB9O1xuXG4gICAgc3dpdGNoIChhcmdbMF0pIHtcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBhcmdEZXRhaWxzLnJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgYXJnRGV0YWlscy5uYW1lID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgYXJnRGV0YWlscy5uYW1lID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGFyZ0RldGFpbHMubmFtZS5sZW5ndGggPiAzICYmIGFyZ0RldGFpbHMubmFtZS5zbGljZSgtMykgPT09ICcuLi4nKSB7XG4gICAgICBhcmdEZXRhaWxzLnZhcmlhZGljID0gdHJ1ZTtcbiAgICAgIGFyZ0RldGFpbHMubmFtZSA9IGFyZ0RldGFpbHMubmFtZS5zbGljZSgwLCAtMyk7XG4gICAgfVxuICAgIGlmIChhcmdEZXRhaWxzLm5hbWUpIHtcbiAgICAgIHNlbGYuX2FyZ3MucHVzaChhcmdEZXRhaWxzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgY2FsbGJhY2sgdG8gdXNlIGFzIHJlcGxhY2VtZW50IGZvciBjYWxsaW5nIHByb2Nlc3MuZXhpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgQ29tbWFuZGVyRXJyb3IsIGRlZmF1bHRzIHRvIHRocm93aW5nXG4gKiBAcmV0dXJuIHtDb21tYW5kfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuZXhpdE92ZXJyaWRlID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKGZuKSB7XG4gICAgdGhpcy5fZXhpdENhbGxiYWNrID0gZm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXhpdENhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgIT09ICdjb21tYW5kZXIuZXhlY3V0ZVN1YkNvbW1hbmRBc3luYycpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXN5bmMgY2FsbGJhY2sgZnJvbSBzcGF3biBldmVudHMsIG5vdCB1c2VmdWwgdG8gdGhyb3cuXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBwcm9jZXNzLmV4aXQsIGFuZCBfZXhpdENhbGxiYWNrIGlmIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGV4aXRDb2RlIGV4aXQgY29kZSBmb3IgdXNpbmcgd2l0aCBwcm9jZXNzLmV4aXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIGFuIGlkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAqIEByZXR1cm4gbmV2ZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLl9leGl0ID0gZnVuY3Rpb24oZXhpdENvZGUsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuX2V4aXRDYWxsYmFjaykge1xuICAgIHRoaXMuX2V4aXRDYWxsYmFjayhuZXcgQ29tbWFuZGVyRXJyb3IoZXhpdENvZGUsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAvLyBFeHBlY3RpbmcgdGhpcyBsaW5lIGlzIG5vdCByZWFjaGVkLlxuICB9XG4gIHByb2Nlc3MuZXhpdChleGl0Q29kZSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGNhbGxiYWNrIGBmbmAgZm9yIHRoZSBjb21tYW5kLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcHJvZ3JhbVxuICogICAgICAgIC5jb21tYW5kKCdoZWxwJylcbiAqICAgICAgICAuZGVzY3JpcHRpb24oJ2Rpc3BsYXkgdmVyYm9zZSBoZWxwJylcbiAqICAgICAgICAuYWN0aW9uKGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgIC8vIG91dHB1dCBoZWxwIGhlcmVcbiAqICAgICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmFjdGlvbiA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oYXJncywgdW5rbm93bikge1xuICAgIC8vIFBhcnNlIGFueSBzby1mYXIgdW5rbm93biBvcHRpb25zXG4gICAgYXJncyA9IGFyZ3MgfHwgW107XG4gICAgdW5rbm93biA9IHVua25vd24gfHwgW107XG5cbiAgICB2YXIgcGFyc2VkID0gc2VsZi5wYXJzZU9wdGlvbnModW5rbm93bik7XG5cbiAgICAvLyBPdXRwdXQgaGVscCBpZiBuZWNlc3NhcnlcbiAgICBvdXRwdXRIZWxwSWZSZXF1ZXN0ZWQoc2VsZiwgcGFyc2VkLnVua25vd24pO1xuICAgIHNlbGYuX2NoZWNrRm9yTWlzc2luZ01hbmRhdG9yeU9wdGlvbnMoKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBzdGlsbCBhbnkgdW5rbm93biBvcHRpb25zLCB0aGVuIHdlIHNpbXBseVxuICAgIC8vIGRpZSwgdW5sZXNzIHNvbWVvbmUgYXNrZWQgZm9yIGhlbHAsIGluIHdoaWNoIGNhc2Ugd2UgZ2l2ZSBpdFxuICAgIC8vIHRvIHRoZW0sIGFuZCB0aGVuIHdlIGRpZS5cbiAgICBpZiAocGFyc2VkLnVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi51bmtub3duT3B0aW9uKHBhcnNlZC51bmtub3duWzBdKTtcbiAgICB9XG5cbiAgICAvLyBMZWZ0b3ZlciBhcmd1bWVudHMgbmVlZCB0byBiZSBwdXNoZWQgYmFjay4gRml4ZXMgaXNzdWUgIzU2XG4gICAgaWYgKHBhcnNlZC5hcmdzLmxlbmd0aCkgYXJncyA9IHBhcnNlZC5hcmdzLmNvbmNhdChhcmdzKTtcblxuICAgIHNlbGYuX2FyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcsIGkpIHtcbiAgICAgIGlmIChhcmcucmVxdWlyZWQgJiYgYXJnc1tpXSA9PSBudWxsKSB7XG4gICAgICAgIHNlbGYubWlzc2luZ0FyZ3VtZW50KGFyZy5uYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnLnZhcmlhZGljKSB7XG4gICAgICAgIGlmIChpICE9PSBzZWxmLl9hcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBzZWxmLnZhcmlhZGljQXJnTm90TGFzdChhcmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzW2ldID0gYXJncy5zcGxpY2UoaSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgLmFjdGlvbiBjYWxsYmFjayB0YWtlcyBhbiBleHRyYSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIGNvbW1hbmQgaXRzZWxmLlxuICAgIHZhciBleHBlY3RlZEFyZ3NDb3VudCA9IHNlbGYuX2FyZ3MubGVuZ3RoO1xuICAgIHZhciBhY3Rpb25BcmdzID0gYXJncy5zbGljZSgwLCBleHBlY3RlZEFyZ3NDb3VudCk7XG4gICAgaWYgKHNlbGYuX3Bhc3NDb21tYW5kVG9BY3Rpb24pIHtcbiAgICAgIGFjdGlvbkFyZ3NbZXhwZWN0ZWRBcmdzQ291bnRdID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uQXJnc1tleHBlY3RlZEFyZ3NDb3VudF0gPSBzZWxmLm9wdHMoKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBleHRyYSBhcmd1bWVudHMgc28gYXZhaWxhYmxlIHRvby5cbiAgICBpZiAoYXJncy5sZW5ndGggPiBleHBlY3RlZEFyZ3NDb3VudCkge1xuICAgICAgYWN0aW9uQXJncy5wdXNoKGFyZ3Muc2xpY2UoZXhwZWN0ZWRBcmdzQ291bnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb25SZXN1bHQgPSBmbi5hcHBseShzZWxmLCBhY3Rpb25BcmdzKTtcbiAgICAvLyBSZW1lbWJlciByZXN1bHQgaW4gY2FzZSBpdCBpcyBhc3luYy4gQXNzdW1lIHBhcnNlQXN5bmMgZ2V0dGluZyBjYWxsZWQgb24gcm9vdC5cbiAgICBsZXQgcm9vdENvbW1hbmQgPSBzZWxmO1xuICAgIHdoaWxlIChyb290Q29tbWFuZC5wYXJlbnQpIHtcbiAgICAgIHJvb3RDb21tYW5kID0gcm9vdENvbW1hbmQucGFyZW50O1xuICAgIH1cbiAgICByb290Q29tbWFuZC5fYWN0aW9uUmVzdWx0cy5wdXNoKGFjdGlvblJlc3VsdCk7XG4gIH07XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzO1xuICB2YXIgbmFtZSA9IHBhcmVudCA9PT0gdGhpcyA/ICcqJyA6IHRoaXMuX25hbWU7XG4gIHBhcmVudC5vbignY29tbWFuZDonICsgbmFtZSwgbGlzdGVuZXIpO1xuICBpZiAodGhpcy5fYWxpYXMpIHBhcmVudC5vbignY29tbWFuZDonICsgdGhpcy5fYWxpYXMsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIHNoYXJlZCBieSAub3B0aW9uKCkgYW5kIC5yZXF1aXJlZE9wdGlvbigpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb258Kn0gW2ZuXSAtIGN1c3RvbSBvcHRpb24gcHJvY2Vzc2luZyBmdW5jdGlvbiBvciBkZWZhdWx0IHZhdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm4ge0NvbW1hbmR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuX29wdGlvbkV4ID0gZnVuY3Rpb24oY29uZmlnLCBmbGFncywgZGVzY3JpcHRpb24sIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIG9wdGlvbiA9IG5ldyBPcHRpb24oZmxhZ3MsIGRlc2NyaXB0aW9uKSxcbiAgICBvbmFtZSA9IG9wdGlvbi5uYW1lKCksXG4gICAgbmFtZSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG4gIG9wdGlvbi5tYW5kYXRvcnkgPSAhIWNvbmZpZy5tYW5kYXRvcnk7XG5cbiAgLy8gZGVmYXVsdCBhcyAzcmQgYXJnXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBiaXQgc2ltcGxpc3RpYyAoZXNwZWNpYWxseSBubyBlcnJvciBtZXNzYWdlcyksIGFuZCBwcm9iYWJseSBiZXR0ZXIgaGFuZGxlZCBieSBjYWxsZXIgdXNpbmcgY3VzdG9tIG9wdGlvbiBwcm9jZXNzaW5nLlxuICAgICAgLy8gTm8gbG9uZ2VyIGRvY3VtZW50ZWQgaW4gUkVBRE1FLCBidXQgc3RpbGwgcHJlc2VudCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICB2YXIgcmVnZXggPSBmbjtcbiAgICAgIGZuID0gZnVuY3Rpb24odmFsLCBkZWYpIHtcbiAgICAgICAgdmFyIG0gPSByZWdleC5leGVjKHZhbCk7XG4gICAgICAgIHJldHVybiBtID8gbVswXSA6IGRlZjtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGZuO1xuICAgICAgZm4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByZWFzc2lnbiBkZWZhdWx0IHZhbHVlIGZvciAtLW5vLSosIFtvcHRpb25hbF0sIDxyZXF1aXJlZD4sIG9yIHBsYWluIGZsYWcgaWYgYm9vbGVhbiB2YWx1ZVxuICBpZiAob3B0aW9uLm5lZ2F0ZSB8fCBvcHRpb24ub3B0aW9uYWwgfHwgb3B0aW9uLnJlcXVpcmVkIHx8IHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIC8vIHdoZW4gLS1uby1mb28gd2UgbWFrZSBzdXJlIGRlZmF1bHQgaXMgdHJ1ZSwgdW5sZXNzIGEgLS1mb28gb3B0aW9uIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgIGlmIChvcHRpb24ubmVnYXRlKSB7XG4gICAgICBjb25zdCBwb3NpdGl2ZUxvbmdGbGFnID0gb3B0aW9uLmxvbmcucmVwbGFjZSgvXi0tbm8tLywgJy0tJyk7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBzZWxmLm9wdGlvbkZvcihwb3NpdGl2ZUxvbmdGbGFnKSA/IHNlbGYuX2dldE9wdGlvblZhbHVlKG5hbWUpIDogdHJ1ZTtcbiAgICB9XG4gICAgLy8gcHJlYXNzaWduIG9ubHkgaWYgd2UgaGF2ZSBhIGRlZmF1bHRcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbGYuX3NldE9wdGlvblZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICBvcHRpb24uZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIHRoZSBvcHRpb25cbiAgdGhpcy5vcHRpb25zLnB1c2gob3B0aW9uKTtcblxuICAvLyB3aGVuIGl0J3MgcGFzc2VkIGFzc2lnbiB0aGUgdmFsdWVcbiAgLy8gYW5kIGNvbmRpdGlvbmFsbHkgaW52b2tlIHRoZSBjYWxsYmFja1xuICB0aGlzLm9uKCdvcHRpb246JyArIG9uYW1lLCBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBjb2VyY2lvblxuICAgIGlmICh2YWwgIT09IG51bGwgJiYgZm4pIHtcbiAgICAgIHZhbCA9IGZuKHZhbCwgc2VsZi5fZ2V0T3B0aW9uVmFsdWUobmFtZSkgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHNlbGYuX2dldE9wdGlvblZhbHVlKG5hbWUpKTtcbiAgICB9XG5cbiAgICAvLyB1bmFzc2lnbmVkIG9yIGJvb2xlYW4gdmFsdWVcbiAgICBpZiAodHlwZW9mIHNlbGYuX2dldE9wdGlvblZhbHVlKG5hbWUpID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHNlbGYuX2dldE9wdGlvblZhbHVlKG5hbWUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gaWYgbm8gdmFsdWUsIG5lZ2F0ZSBmYWxzZSwgYW5kIHdlIGhhdmUgYSBkZWZhdWx0LCB0aGVuIHVzZSBpdCFcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBzZWxmLl9zZXRPcHRpb25WYWx1ZShuYW1lLCBvcHRpb24ubmVnYXRlXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogZGVmYXVsdFZhbHVlIHx8IHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fc2V0T3B0aW9uVmFsdWUobmFtZSwgdmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgLy8gcmVhc3NpZ25cbiAgICAgIHNlbGYuX3NldE9wdGlvblZhbHVlKG5hbWUsIG9wdGlvbi5uZWdhdGUgPyBmYWxzZSA6IHZhbCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lIG9wdGlvbiB3aXRoIGBmbGFnc2AsIGBkZXNjcmlwdGlvbmAgYW5kIG9wdGlvbmFsXG4gKiBjb2VyY2lvbiBgZm5gLlxuICpcbiAqIFRoZSBgZmxhZ3NgIHN0cmluZyBzaG91bGQgY29udGFpbiBib3RoIHRoZSBzaG9ydCBhbmQgbG9uZyBmbGFncyxcbiAqIHNlcGFyYXRlZCBieSBjb21tYSwgYSBwaXBlIG9yIHNwYWNlLiBUaGUgZm9sbG93aW5nIGFyZSBhbGwgdmFsaWRcbiAqIGFsbCB3aWxsIG91dHB1dCB0aGlzIHdheSB3aGVuIGAtLWhlbHBgIGlzIHVzZWQuXG4gKlxuICogICAgXCItcCwgLS1wZXBwZXJcIlxuICogICAgXCItcHwtLXBlcHBlclwiXG4gKiAgICBcIi1wIC0tcGVwcGVyXCJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgLy8gc2ltcGxlIGJvb2xlYW4gZGVmYXVsdGluZyB0byB1bmRlZmluZWRcbiAqICAgICBwcm9ncmFtLm9wdGlvbignLXAsIC0tcGVwcGVyJywgJ2FkZCBwZXBwZXInKTtcbiAqXG4gKiAgICAgcHJvZ3JhbS5wZXBwZXJcbiAqICAgICAvLyA9PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgLS1wZXBwZXJcbiAqICAgICBwcm9ncmFtLnBlcHBlclxuICogICAgIC8vID0+IHRydWVcbiAqXG4gKiAgICAgLy8gc2ltcGxlIGJvb2xlYW4gZGVmYXVsdGluZyB0byB0cnVlICh1bmxlc3Mgbm9uLW5lZ2F0ZWQgb3B0aW9uIGlzIGFsc28gZGVmaW5lZClcbiAqICAgICBwcm9ncmFtLm9wdGlvbignLUMsIC0tbm8tY2hlZXNlJywgJ3JlbW92ZSBjaGVlc2UnKTtcbiAqXG4gKiAgICAgcHJvZ3JhbS5jaGVlc2VcbiAqICAgICAvLyA9PiB0cnVlXG4gKlxuICogICAgIC0tbm8tY2hlZXNlXG4gKiAgICAgcHJvZ3JhbS5jaGVlc2VcbiAqICAgICAvLyA9PiBmYWxzZVxuICpcbiAqICAgICAvLyByZXF1aXJlZCBhcmd1bWVudFxuICogICAgIHByb2dyYW0ub3B0aW9uKCctQywgLS1jaGRpciA8cGF0aD4nLCAnY2hhbmdlIHRoZSB3b3JraW5nIGRpcmVjdG9yeScpO1xuICpcbiAqICAgICAtLWNoZGlyIC90bXBcbiAqICAgICBwcm9ncmFtLmNoZGlyXG4gKiAgICAgLy8gPT4gXCIvdG1wXCJcbiAqXG4gKiAgICAgLy8gb3B0aW9uYWwgYXJndW1lbnRcbiAqICAgICBwcm9ncmFtLm9wdGlvbignLWMsIC0tY2hlZXNlIFt0eXBlXScsICdhZGQgY2hlZXNlIFttYXJibGVdJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb258Kn0gW2ZuXSAtIGN1c3RvbSBvcHRpb24gcHJvY2Vzc2luZyBmdW5jdGlvbiBvciBkZWZhdWx0IHZhdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm4ge0NvbW1hbmR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbihmbGFncywgZGVzY3JpcHRpb24sIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX29wdGlvbkV4KHt9LCBmbGFncywgZGVzY3JpcHRpb24sIGZuLCBkZWZhdWx0VmFsdWUpO1xufTtcblxuLypcbiAqIEFkZCBhIHJlcXVpcmVkIG9wdGlvbiB3aGljaCBtdXN0IGhhdmUgYSB2YWx1ZSBhZnRlciBwYXJzaW5nLiBUaGlzIHVzdWFsbHkgbWVhbnNcbiAqIHRoZSBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgb24gdGhlIGNvbW1hbmQgbGluZS4gKE90aGVyd2lzZSB0aGUgc2FtZSBhcyAub3B0aW9uKCkuKVxuICpcbiAqIFRoZSBgZmxhZ3NgIHN0cmluZyBzaG91bGQgY29udGFpbiBib3RoIHRoZSBzaG9ydCBhbmQgbG9uZyBmbGFncywgc2VwYXJhdGVkIGJ5IGNvbW1hLCBhIHBpcGUgb3Igc3BhY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb258Kn0gW2ZuXSAtIGN1c3RvbSBvcHRpb24gcHJvY2Vzc2luZyBmdW5jdGlvbiBvciBkZWZhdWx0IHZhdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm4ge0NvbW1hbmR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5yZXF1aXJlZE9wdGlvbiA9IGZ1bmN0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbiwgZm4sIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdGhpcy5fb3B0aW9uRXgoeyBtYW5kYXRvcnk6IHRydWUgfSwgZmxhZ3MsIGRlc2NyaXB0aW9uLCBmbiwgZGVmYXVsdFZhbHVlKTtcbn07XG5cbi8qKlxuICogQWxsb3cgdW5rbm93biBvcHRpb25zIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBhcmcgaWYgYHRydWVgIG9yIG9taXR0ZWQsIG5vIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiBmb3IgdW5rbm93biBvcHRpb25zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQ29tbWFuZC5wcm90b3R5cGUuYWxsb3dVbmtub3duT3B0aW9uID0gZnVuY3Rpb24oYXJnKSB7XG4gIHRoaXMuX2FsbG93VW5rbm93bk9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgYXJnO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICAqIFdoZXRoZXIgdG8gc3RvcmUgb3B0aW9uIHZhbHVlcyBhcyBwcm9wZXJ0aWVzIG9uIGNvbW1hbmQgb2JqZWN0LFxuICAqIG9yIHN0b3JlIHNlcGFyYXRlbHkgKHNwZWNpZnkgZmFsc2UpLiBJbiBib3RoIGNhc2VzIHRoZSBvcHRpb24gdmFsdWVzIGNhbiBiZSBhY2Nlc3NlZCB1c2luZyAub3B0cygpLlxuICAqXG4gICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICAqIEByZXR1cm4ge0NvbW1hbmR9IENvbW1hbmQgZm9yIGNoYWluaW5nXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzID0gKHZhbHVlID09PSB1bmRlZmluZWQpIHx8IHZhbHVlO1xuICBpZiAodGhpcy5vcHRpb25zLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgaXMgZm9yIHByb2dyYW1tZXIsIG5vdCBlbmQgdXNlci5cbiAgICBjb25zb2xlLmVycm9yKCdDb21tYW5kZXIgdXNhZ2UgZXJyb3I6IGNhbGwgc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzIGJlZm9yZSBhZGRpbmcgb3B0aW9ucycpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gICogV2hldGhlciB0byBwYXNzIGNvbW1hbmQgdG8gYWN0aW9uIGhhbmRsZXIsXG4gICogb3IganVzdCB0aGUgb3B0aW9ucyAoc3BlY2lmeSBmYWxzZSkuXG4gICpcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gICogQHJldHVybiB7Q29tbWFuZH0gQ29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5wYXNzQ29tbWFuZFRvQWN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5fcGFzc0NvbW1hbmRUb0FjdGlvbiA9ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB8fCB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0b3JlIG9wdGlvbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuX3NldE9wdGlvblZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3B0aW9uVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBvcHRpb24gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKHRoaXMuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcykge1xuICAgIHJldHVybiB0aGlzW2tleV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX29wdGlvblZhbHVlc1trZXldO1xufTtcblxuLyoqXG4gKiBQYXJzZSBgYXJndmAsIHNldHRpbmcgb3B0aW9ucyBhbmQgaW52b2tpbmcgY29tbWFuZHMgd2hlbiBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3ZcbiAqIEByZXR1cm4ge0NvbW1hbmR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGFyZ3YpIHtcbiAgLy8gaW1wbGljaXQgaGVscFxuICBpZiAodGhpcy5leGVjdXRhYmxlcykgdGhpcy5hZGRJbXBsaWNpdEhlbHBDb21tYW5kKCk7XG5cbiAgLy8gc3RvcmUgcmF3IGFyZ3NcbiAgdGhpcy5yYXdBcmdzID0gYXJndjtcblxuICAvLyBndWVzcyBuYW1lXG4gIHRoaXMuX25hbWUgPSB0aGlzLl9uYW1lIHx8IGJhc2VuYW1lKGFyZ3ZbMV0sICcuanMnKTtcblxuICAvLyBnaXRodWItc3R5bGUgc3ViLWNvbW1hbmRzIHdpdGggbm8gc3ViLWNvbW1hbmRcbiAgaWYgKHRoaXMuZXhlY3V0YWJsZXMgJiYgYXJndi5sZW5ndGggPCAzICYmICF0aGlzLmRlZmF1bHRFeGVjdXRhYmxlKSB7XG4gICAgLy8gdGhpcyB1c2VyIG5lZWRzIGhlbHBcbiAgICBhcmd2LnB1c2godGhpcy5faGVscExvbmdGbGFnKTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYXJndlxuICB2YXIgbm9ybWFsaXplZCA9IHRoaXMubm9ybWFsaXplKGFyZ3Yuc2xpY2UoMikpO1xuICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZU9wdGlvbnMobm9ybWFsaXplZCk7XG4gIHZhciBhcmdzID0gdGhpcy5hcmdzID0gcGFyc2VkLmFyZ3M7XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VBcmdzKHRoaXMuYXJncywgcGFyc2VkLnVua25vd24pO1xuXG4gIGlmIChhcmdzWzBdID09PSAnaGVscCcgJiYgYXJncy5sZW5ndGggPT09IDEpIHRoaXMuaGVscCgpO1xuXG4gIC8vIE5vdGUgZm9yIGZ1dHVyZTogd2UgY291bGQgcmV0dXJuIGVhcmx5IGlmIHdlIGZvdW5kIGFuIGFjdGlvbiBoYW5kbGVyIGluIHBhcnNlQXJncywgYXMgbm9uZSBvZiBmb2xsb3dpbmcgY29kZSBuZWVkZWQ/XG5cbiAgLy8gPGNtZD4gLS1oZWxwXG4gIGlmIChhcmdzWzBdID09PSAnaGVscCcpIHtcbiAgICBhcmdzWzBdID0gYXJnc1sxXTtcbiAgICBhcmdzWzFdID0gdGhpcy5faGVscExvbmdGbGFnO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGNhbGxpbmcgdGhyb3VnaCB0byBleGVjdXRhYmxlIHN1YmNvbW1hbmQgd2UgY291bGQgY2hlY2sgZm9yIGhlbHAgZmxhZ3MgYmVmb3JlIGZhaWxpbmcsXG4gICAgLy8gYnV0IGEgc29tZXdoYXQgdW5saWtlbHkgY2FzZSBzaW5jZSBwcm9ncmFtIG9wdGlvbnMgbm90IHBhc3NlZCB0byBleGVjdXRhYmxlIHN1YmNvbW1hbmRzLlxuICAgIC8vIFdhaXQgZm9yIHJlcG9ydHMgdG8gc2VlIGlmIGNoZWNrIG5lZWRlZCBhbmQgd2hhdCB1c2FnZSBwYXR0ZXJuIGlzLlxuICAgIHRoaXMuX2NoZWNrRm9yTWlzc2luZ01hbmRhdG9yeU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8vIGV4ZWN1dGFibGUgc3ViLWNvbW1hbmRzXG4gIC8vIChEZWJ1Z2dpbmcgbm90ZSBmb3IgZnV0dXJlOiBhcmdzWzBdIGlzIG5vdCByaWdodCBpZiBhbiBhY3Rpb24gaGFzIGJlZW4gY2FsbGVkKVxuICB2YXIgbmFtZSA9IHJlc3VsdC5hcmdzWzBdO1xuICB2YXIgc3ViQ29tbWFuZCA9IG51bGw7XG5cbiAgLy8gTG9vayBmb3Igc3ViY29tbWFuZFxuICBpZiAobmFtZSkge1xuICAgIHN1YkNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmZpbmQoZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgcmV0dXJuIGNvbW1hbmQuX25hbWUgPT09IG5hbWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyBMb29rIGZvciBhbGlhc1xuICBpZiAoIXN1YkNvbW1hbmQgJiYgbmFtZSkge1xuICAgIHN1YkNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmZpbmQoZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgcmV0dXJuIGNvbW1hbmQuYWxpYXMoKSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViQ29tbWFuZCkge1xuICAgICAgbmFtZSA9IHN1YkNvbW1hbmQuX25hbWU7XG4gICAgICBhcmdzWzBdID0gbmFtZTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciBkZWZhdWx0IHN1YmNvbW1hbmRcbiAgaWYgKCFzdWJDb21tYW5kICYmIHRoaXMuZGVmYXVsdEV4ZWN1dGFibGUpIHtcbiAgICBuYW1lID0gdGhpcy5kZWZhdWx0RXhlY3V0YWJsZTtcbiAgICBhcmdzLnVuc2hpZnQobmFtZSk7XG4gICAgc3ViQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMuZmluZChmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICByZXR1cm4gY29tbWFuZC5fbmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9leGVjcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlU3ViQ29tbWFuZChhcmd2LCBhcmdzLCBwYXJzZWQudW5rbm93biwgc3ViQ29tbWFuZCA/IHN1YkNvbW1hbmQuX2V4ZWN1dGFibGVGaWxlIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGBhcmd2YCwgc2V0dGluZyBvcHRpb25zIGFuZCBpbnZva2luZyBjb21tYW5kcyB3aGVuIGRlZmluZWQuXG4gKlxuICogVXNlIHBhcnNlQXN5bmMgaW5zdGVhZCBvZiBwYXJzZSBpZiBhbnkgb2YgeW91ciBhY3Rpb24gaGFuZGxlcnMgYXJlIGFzeW5jLiBSZXR1cm5zIGEgUHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd2XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuQ29tbWFuZC5wcm90b3R5cGUucGFyc2VBc3luYyA9IGZ1bmN0aW9uKGFyZ3YpIHtcbiAgdGhpcy5wYXJzZShhcmd2KTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuX2FjdGlvblJlc3VsdHMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgc3ViLWNvbW1hbmQgZXhlY3V0YWJsZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd2XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcGFyYW0ge0FycmF5fSB1bmtub3duXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhlY3V0YWJsZUZpbGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGVTdWJDb21tYW5kID0gZnVuY3Rpb24oYXJndiwgYXJncywgdW5rbm93biwgZXhlY3V0YWJsZUZpbGUpIHtcbiAgYXJncyA9IGFyZ3MuY29uY2F0KHVua25vd24pO1xuXG4gIGlmICghYXJncy5sZW5ndGgpIHRoaXMuaGVscCgpO1xuXG4gIHZhciBpc0V4cGxpY2l0SlMgPSBmYWxzZTsgLy8gV2hldGhlciB0byB1c2Ugbm9kZSB0byBsYXVuY2ggXCJleGVjdXRhYmxlXCJcblxuICAvLyBleGVjdXRhYmxlXG4gIHZhciBwbSA9IGFyZ3ZbMV07XG4gIC8vIG5hbWUgb2YgdGhlIHN1YmNvbW1hbmQsIGxpa2UgYHBtLWluc3RhbGxgXG4gIHZhciBiaW4gPSBiYXNlbmFtZShwbSwgcGF0aC5leHRuYW1lKHBtKSkgKyAnLScgKyBhcmdzWzBdO1xuICBpZiAoZXhlY3V0YWJsZUZpbGUgIT0gbnVsbCkge1xuICAgIGJpbiA9IGV4ZWN1dGFibGVGaWxlO1xuICAgIC8vIENoZWNrIGZvciBzYW1lIGV4dGVuc2lvbnMgYXMgd2Ugc2NhbiBmb3IgYmVsb3cgc28gZ2V0IGNvbnNpc3RlbnQgbGF1bmNoIGJlaGF2aW91ci5cbiAgICB2YXIgZXhlY3V0YWJsZUV4dCA9IHBhdGguZXh0bmFtZShleGVjdXRhYmxlRmlsZSk7XG4gICAgaXNFeHBsaWNpdEpTID0gZXhlY3V0YWJsZUV4dCA9PT0gJy5qcycgfHwgZXhlY3V0YWJsZUV4dCA9PT0gJy50cycgfHwgZXhlY3V0YWJsZUV4dCA9PT0gJy5tanMnO1xuICB9XG5cbiAgLy8gSW4gY2FzZSBvZiBnbG9iYWxseSBpbnN0YWxsZWQsIGdldCB0aGUgYmFzZSBkaXIgd2hlcmUgZXhlY3V0YWJsZVxuICAvLyAgc3ViY29tbWFuZCBmaWxlIHNob3VsZCBiZSBsb2NhdGVkIGF0XG4gIHZhciBiYXNlRGlyO1xuXG4gIHZhciByZXNvbHZlZExpbmsgPSBmcy5yZWFscGF0aFN5bmMocG0pO1xuXG4gIGJhc2VEaXIgPSBkaXJuYW1lKHJlc29sdmVkTGluayk7XG5cbiAgLy8gcHJlZmVyIGxvY2FsIGAuLzxiaW4+YCB0byBiaW4gaW4gdGhlICRQQVRIXG4gIHZhciBsb2NhbEJpbiA9IHBhdGguam9pbihiYXNlRGlyLCBiaW4pO1xuXG4gIC8vIHdoZXRoZXIgYmluIGZpbGUgaXMgYSBqcyBzY3JpcHQgd2l0aCBleHBsaWNpdCBgLmpzYCBvciBgLnRzYCBleHRlbnNpb25cbiAgaWYgKGV4aXN0cyhsb2NhbEJpbiArICcuanMnKSkge1xuICAgIGJpbiA9IGxvY2FsQmluICsgJy5qcyc7XG4gICAgaXNFeHBsaWNpdEpTID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleGlzdHMobG9jYWxCaW4gKyAnLnRzJykpIHtcbiAgICBiaW4gPSBsb2NhbEJpbiArICcudHMnO1xuICAgIGlzRXhwbGljaXRKUyA9IHRydWU7XG4gIH0gZWxzZSBpZiAoZXhpc3RzKGxvY2FsQmluICsgJy5tanMnKSkge1xuICAgIGJpbiA9IGxvY2FsQmluICsgJy5tanMnO1xuICAgIGlzRXhwbGljaXRKUyA9IHRydWU7XG4gIH0gZWxzZSBpZiAoZXhpc3RzKGxvY2FsQmluKSkge1xuICAgIGJpbiA9IGxvY2FsQmluO1xuICB9XG5cbiAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG5cbiAgdmFyIHByb2M7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgaWYgKGlzRXhwbGljaXRKUykge1xuICAgICAgYXJncy51bnNoaWZ0KGJpbik7XG4gICAgICAvLyBhZGQgZXhlY3V0YWJsZSBhcmd1bWVudHMgdG8gc3Bhd25cbiAgICAgIGFyZ3MgPSBpbmNyZW1lbnROb2RlSW5zcGVjdG9yUG9ydChwcm9jZXNzLmV4ZWNBcmd2KS5jb25jYXQoYXJncyk7XG5cbiAgICAgIHByb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvYyA9IHNwYXduKGJpbiwgYXJncywgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcmdzLnVuc2hpZnQoYmluKTtcbiAgICAvLyBhZGQgZXhlY3V0YWJsZSBhcmd1bWVudHMgdG8gc3Bhd25cbiAgICBhcmdzID0gaW5jcmVtZW50Tm9kZUluc3BlY3RvclBvcnQocHJvY2Vzcy5leGVjQXJndikuY29uY2F0KGFyZ3MpO1xuICAgIHByb2MgPSBzcGF3bihwcm9jZXNzLmV4ZWNQYXRoLCBhcmdzLCB7IHN0ZGlvOiAnaW5oZXJpdCcgfSk7XG4gIH1cblxuICB2YXIgc2lnbmFscyA9IFsnU0lHVVNSMScsICdTSUdVU1IyJywgJ1NJR1RFUk0nLCAnU0lHSU5UJywgJ1NJR0hVUCddO1xuICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24oc2lnbmFsKSB7XG4gICAgcHJvY2Vzcy5vbihzaWduYWwsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Mua2lsbGVkID09PSBmYWxzZSAmJiBwcm9jLmV4aXRDb2RlID09PSBudWxsKSB7XG4gICAgICAgIHByb2Mua2lsbChzaWduYWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBCeSBkZWZhdWx0IHRlcm1pbmF0ZSBwcm9jZXNzIHdoZW4gc3Bhd25lZCBwcm9jZXNzIHRlcm1pbmF0ZXMuXG4gIC8vIFN1cHByZXNzaW5nIHRoZSBleGl0IGlmIGV4aXRDYWxsYmFjayBkZWZpbmVkIGlzIGEgYml0IG1lc3N5IGFuZCBvZiBsaW1pdGVkIHVzZSwgYnV0IGRvZXMgYWxsb3cgcHJvY2VzcyB0byBzdGF5IHJ1bm5pbmchXG4gIGNvbnN0IGV4aXRDYWxsYmFjayA9IHRoaXMuX2V4aXRDYWxsYmFjaztcbiAgaWYgKCFleGl0Q2FsbGJhY2spIHtcbiAgICBwcm9jLm9uKCdjbG9zZScsIHByb2Nlc3MuZXhpdC5iaW5kKHByb2Nlc3MpKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGV4aXRDYWxsYmFjayhuZXcgQ29tbWFuZGVyRXJyb3IocHJvY2Vzcy5leGl0Q29kZSB8fCAwLCAnY29tbWFuZGVyLmV4ZWN1dGVTdWJDb21tYW5kQXN5bmMnLCAnKGNsb3NlKScpKTtcbiAgICB9KTtcbiAgfVxuICBwcm9jLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiAlcygxKSBkb2VzIG5vdCBleGlzdCwgdHJ5IC0taGVscCcsIGJpbik7XG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gJ0VBQ0NFUycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiAlcygxKSBub3QgZXhlY3V0YWJsZS4gdHJ5IGNobW9kIG9yIHJ1biB3aXRoIHJvb3QnLCBiaW4pO1xuICAgIH1cbiAgICBpZiAoIWV4aXRDYWxsYmFjaykge1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cmFwcGVkRXJyb3IgPSBuZXcgQ29tbWFuZGVyRXJyb3IoMSwgJ2NvbW1hbmRlci5leGVjdXRlU3ViQ29tbWFuZEFzeW5jJywgJyhlcnJvciknKTtcbiAgICAgIHdyYXBwZWRFcnJvci5uZXN0ZWRFcnJvciA9IGVycjtcbiAgICAgIGV4aXRDYWxsYmFjayh3cmFwcGVkRXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgcHJvY2Vzc1xuICB0aGlzLnJ1bm5pbmdDb21tYW5kID0gcHJvYztcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGBhcmdzYCwgc3BsaXR0aW5nIGpvaW5lZCBzaG9ydCBmbGFncy4gRm9yIGV4YW1wbGVcbiAqIHRoZSBhcmcgXCItYWJjXCIgaXMgZXF1aXZhbGVudCB0byBcIi1hIC1iIC1jXCIuXG4gKiBUaGlzIGFsc28gbm9ybWFsaXplcyBlcXVhbCBzaWduIGFuZCBzcGxpdHMgXCItLWFiYz1kZWZcIiBpbnRvIFwiLS1hYmMgZGVmXCIuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICBhcmcsXG4gICAgbGFzdE9wdCxcbiAgICBpbmRleCxcbiAgICBzaG9ydCxcbiAgICBvcHQ7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgbGFzdE9wdCA9IHRoaXMub3B0aW9uRm9yKGFyZ3NbaSAtIDFdKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnID09PSAnLS0nKSB7XG4gICAgICAvLyBIb25vciBvcHRpb24gdGVybWluYXRvclxuICAgICAgcmV0ID0gcmV0LmNvbmNhdChhcmdzLnNsaWNlKGkpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobGFzdE9wdCAmJiBsYXN0T3B0LnJlcXVpcmVkKSB7XG4gICAgICByZXQucHVzaChhcmcpO1xuICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCA+IDIgJiYgYXJnWzBdID09PSAnLScgJiYgYXJnWzFdICE9PSAnLScpIHtcbiAgICAgIHNob3J0ID0gYXJnLnNsaWNlKDAsIDIpO1xuICAgICAgb3B0ID0gdGhpcy5vcHRpb25Gb3Ioc2hvcnQpO1xuICAgICAgaWYgKG9wdCAmJiAob3B0LnJlcXVpcmVkIHx8IG9wdC5vcHRpb25hbCkpIHtcbiAgICAgICAgcmV0LnB1c2goc2hvcnQpO1xuICAgICAgICByZXQucHVzaChhcmcuc2xpY2UoMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnLnNsaWNlKDEpLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXQucHVzaCgnLScgKyBjKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvXi0tLy50ZXN0KGFyZykgJiYgfihpbmRleCA9IGFyZy5pbmRleE9mKCc9JykpKSB7XG4gICAgICByZXQucHVzaChhcmcuc2xpY2UoMCwgaW5kZXgpLCBhcmcuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGFyZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUGFyc2UgY29tbWFuZCBgYXJnc2AuXG4gKlxuICogV2hlbiBsaXN0ZW5lcihzKSBhcmUgYXZhaWxhYmxlIHRob3NlXG4gKiBjYWxsYmFja3MgYXJlIGludm9rZWQsIG90aGVyd2lzZSB0aGUgXCIqXCJcbiAqIGV2ZW50IGlzIGVtaXR0ZWQgYW5kIHRob3NlIGFjdGlvbnMgYXJlIGludm9rZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5wYXJzZUFyZ3MgPSBmdW5jdGlvbihhcmdzLCB1bmtub3duKSB7XG4gIHZhciBuYW1lO1xuXG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIG5hbWUgPSBhcmdzWzBdO1xuICAgIGlmICh0aGlzLmxpc3RlbmVycygnY29tbWFuZDonICsgbmFtZSkubGVuZ3RoKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NvbW1hbmQ6JyArIGFyZ3Muc2hpZnQoKSwgYXJncywgdW5rbm93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnY29tbWFuZDoqJywgYXJncywgdW5rbm93bik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dHB1dEhlbHBJZlJlcXVlc3RlZCh0aGlzLCB1bmtub3duKTtcblxuICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gYXJncyBhbmQgd2UgaGF2ZSB1bmtub3duIG9wdGlvbnMsXG4gICAgLy8gdGhlbiB0aGV5IGFyZSBleHRyYW5lb3VzIGFuZCB3ZSBuZWVkIHRvIGVycm9yLlxuICAgIGlmICh1bmtub3duLmxlbmd0aCA+IDAgJiYgIXRoaXMuZGVmYXVsdEV4ZWN1dGFibGUpIHtcbiAgICAgIHRoaXMudW5rbm93bk9wdGlvbih1bmtub3duWzBdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHRoaXMuX2FyZ3MuZmlsdGVyKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEucmVxdWlyZWQ7IH0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjb21tYW5kOionKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIG9wdGlvbiBtYXRjaGluZyBgYXJnYCBpZiBhbnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7T3B0aW9ufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUub3B0aW9uRm9yID0gZnVuY3Rpb24oYXJnKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zW2ldLmlzKGFyZykpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbaV07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBpZiBhIG1hbmRhdG9yeSBvcHRpb24gZG9lcyBub3QgaGF2ZSBhIHZhbHVlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLl9jaGVja0Zvck1pc3NpbmdNYW5kYXRvcnlPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIC8vIFdhbGsgdXAgaGllcmFyY2h5IHNvIGNhbiBjYWxsIGZyb20gYWN0aW9uIGhhbmRsZXIgYWZ0ZXIgY2hlY2tpbmcgZm9yIGRpc3BsYXlpbmcgaGVscC5cbiAgZm9yICh2YXIgY21kID0gdGhpczsgY21kOyBjbWQgPSBjbWQucGFyZW50KSB7XG4gICAgY21kLm9wdGlvbnMuZm9yRWFjaCgoYW5PcHRpb24pID0+IHtcbiAgICAgIGlmIChhbk9wdGlvbi5tYW5kYXRvcnkgJiYgKGNtZC5fZ2V0T3B0aW9uVmFsdWUoYW5PcHRpb24uYXR0cmlidXRlTmFtZSgpKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjbWQubWlzc2luZ01hbmRhdG9yeU9wdGlvblZhbHVlKGFuT3B0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBvcHRpb25zIGZyb20gYGFyZ3ZgIHJldHVybmluZyBgYXJndmBcbiAqIHZvaWQgb2YgdGhlc2Ugb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd2XG4gKiBAcmV0dXJuIHt7YXJnczogQXJyYXksIHVua25vd246IEFycmF5fX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUucGFyc2VPcHRpb25zID0gZnVuY3Rpb24oYXJndikge1xuICB2YXIgYXJncyA9IFtdLFxuICAgIGxlbiA9IGFyZ3YubGVuZ3RoLFxuICAgIGxpdGVyYWwsXG4gICAgb3B0aW9uLFxuICAgIGFyZztcblxuICB2YXIgdW5rbm93bk9wdGlvbnMgPSBbXTtcblxuICAvLyBwYXJzZSBvcHRpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcmcgPSBhcmd2W2ldO1xuXG4gICAgLy8gbGl0ZXJhbCBhcmdzIGFmdGVyIC0tXG4gICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFyZyA9PT0gJy0tJykge1xuICAgICAgbGl0ZXJhbCA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIG1hdGNoaW5nIE9wdGlvblxuICAgIG9wdGlvbiA9IHRoaXMub3B0aW9uRm9yKGFyZyk7XG5cbiAgICAvLyBvcHRpb24gaXMgZGVmaW5lZFxuICAgIGlmIChvcHRpb24pIHtcbiAgICAgIC8vIHJlcXVpcmVzIGFyZ1xuICAgICAgaWYgKG9wdGlvbi5yZXF1aXJlZCkge1xuICAgICAgICBhcmcgPSBhcmd2WysraV07XG4gICAgICAgIGlmIChhcmcgPT0gbnVsbCkgcmV0dXJuIHRoaXMub3B0aW9uTWlzc2luZ0FyZ3VtZW50KG9wdGlvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnb3B0aW9uOicgKyBvcHRpb24ubmFtZSgpLCBhcmcpO1xuICAgICAgLy8gb3B0aW9uYWwgYXJnXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbi5vcHRpb25hbCkge1xuICAgICAgICBhcmcgPSBhcmd2W2kgKyAxXTtcbiAgICAgICAgaWYgKGFyZyA9PSBudWxsIHx8IChhcmdbMF0gPT09ICctJyAmJiBhcmcgIT09ICctJykpIHtcbiAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ29wdGlvbjonICsgb3B0aW9uLm5hbWUoKSwgYXJnKTtcbiAgICAgIC8vIGZsYWdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnb3B0aW9uOicgKyBvcHRpb24ubmFtZSgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxvb2tzIGxpa2UgYW4gb3B0aW9uXG4gICAgaWYgKGFyZy5sZW5ndGggPiAxICYmIGFyZ1swXSA9PT0gJy0nKSB7XG4gICAgICB1bmtub3duT3B0aW9ucy5wdXNoKGFyZyk7XG5cbiAgICAgIC8vIElmIHRoZSBuZXh0IGFyZ3VtZW50IGxvb2tzIGxpa2UgaXQgbWlnaHQgYmVcbiAgICAgIC8vIGFuIGFyZ3VtZW50IGZvciB0aGlzIG9wdGlvbiwgd2UgcGFzcyBpdCBvbi5cbiAgICAgIC8vIElmIGl0IGlzbid0LCB0aGVuIGl0J2xsIHNpbXBseSBiZSBpZ25vcmVkXG4gICAgICBpZiAoKGkgKyAxKSA8IGFyZ3YubGVuZ3RoICYmIChhcmd2W2kgKyAxXVswXSAhPT0gJy0nIHx8IGFyZ3ZbaSArIDFdID09PSAnLScpKSB7XG4gICAgICAgIHVua25vd25PcHRpb25zLnB1c2goYXJndlsrK2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGFyZ1xuICAgIGFyZ3MucHVzaChhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHsgYXJnczogYXJncywgdW5rbm93bjogdW5rbm93bk9wdGlvbnMgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgYXMga2V5LXZhbHVlIHBhaXJzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuQ29tbWFuZC5wcm90b3R5cGUub3B0cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzKSB7XG4gICAgLy8gUHJlc2VydmUgb3JpZ2luYWwgYmVoYXZpb3VyIHNvIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdoZW4gc3RpbGwgdXNpbmcgcHJvcGVydGllc1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgIGxlbiA9IHRoaXMub3B0aW9ucy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5vcHRpb25zW2ldLmF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgIHJlc3VsdFtrZXldID0ga2V5ID09PSB0aGlzLl92ZXJzaW9uT3B0aW9uTmFtZSA/IHRoaXMuX3ZlcnNpb24gOiB0aGlzW2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fb3B0aW9uVmFsdWVzO1xufTtcblxuLyoqXG4gKiBBcmd1bWVudCBgbmFtZWAgaXMgbWlzc2luZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubWlzc2luZ0FyZ3VtZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zdCBtZXNzYWdlID0gYGVycm9yOiBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50ICcke25hbWV9J2A7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRoaXMuX2V4aXQoMSwgJ2NvbW1hbmRlci5taXNzaW5nQXJndW1lbnQnLCBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogYE9wdGlvbmAgaXMgbWlzc2luZyBhbiBhcmd1bWVudCwgYnV0IHJlY2VpdmVkIGBmbGFnYCBvciBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9ufSBvcHRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLm9wdGlvbk1pc3NpbmdBcmd1bWVudCA9IGZ1bmN0aW9uKG9wdGlvbiwgZmxhZykge1xuICBsZXQgbWVzc2FnZTtcbiAgaWYgKGZsYWcpIHtcbiAgICBtZXNzYWdlID0gYGVycm9yOiBvcHRpb24gJyR7b3B0aW9uLmZsYWdzfScgYXJndW1lbnQgbWlzc2luZywgZ290ICcke2ZsYWd9J2A7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IGBlcnJvcjogb3B0aW9uICcke29wdGlvbi5mbGFnc30nIGFyZ3VtZW50IG1pc3NpbmdgO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRoaXMuX2V4aXQoMSwgJ2NvbW1hbmRlci5vcHRpb25NaXNzaW5nQXJndW1lbnQnLCBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogYE9wdGlvbmAgZG9lcyBub3QgaGF2ZSBhIHZhbHVlLCBhbmQgaXMgYSBtYW5kYXRvcnkgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9ufSBvcHRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLm1pc3NpbmdNYW5kYXRvcnlPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICBjb25zdCBtZXNzYWdlID0gYGVycm9yOiByZXF1aXJlZCBvcHRpb24gJyR7b3B0aW9uLmZsYWdzfScgbm90IHNwZWNpZmllZGA7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRoaXMuX2V4aXQoMSwgJ2NvbW1hbmRlci5taXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWUnLCBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogVW5rbm93biBvcHRpb24gYGZsYWdgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS51bmtub3duT3B0aW9uID0gZnVuY3Rpb24oZmxhZykge1xuICBpZiAodGhpcy5fYWxsb3dVbmtub3duT3B0aW9uKSByZXR1cm47XG4gIGNvbnN0IG1lc3NhZ2UgPSBgZXJyb3I6IHVua25vd24gb3B0aW9uICcke2ZsYWd9J2A7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRoaXMuX2V4aXQoMSwgJ2NvbW1hbmRlci51bmtub3duT3B0aW9uJywgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIFZhcmlhZGljIGFyZ3VtZW50IHdpdGggYG5hbWVgIGlzIG5vdCB0aGUgbGFzdCBhcmd1bWVudCBhcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUudmFyaWFkaWNBcmdOb3RMYXN0ID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zdCBtZXNzYWdlID0gYGVycm9yOiB2YXJpYWRpYyBhcmd1bWVudHMgbXVzdCBiZSBsYXN0ICcke25hbWV9J2A7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIHRoaXMuX2V4aXQoMSwgJ2NvbW1hbmRlci52YXJpYWRpY0FyZ05vdExhc3QnLCBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwcm9ncmFtIHZlcnNpb24gdG8gYHN0cmAuXG4gKlxuICogVGhpcyBtZXRob2QgYXV0by1yZWdpc3RlcnMgdGhlIFwiLVYsIC0tdmVyc2lvblwiIGZsYWdcbiAqIHdoaWNoIHdpbGwgcHJpbnQgdGhlIHZlcnNpb24gbnVtYmVyIHdoZW4gcGFzc2VkLlxuICpcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBzdXBwbHkgdGhlICBmbGFncyBhbmQgZGVzY3JpcHRpb24gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnZlcnNpb24gPSBmdW5jdGlvbihzdHIsIGZsYWdzLCBkZXNjcmlwdGlvbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIHRoaXMuX3ZlcnNpb24gPSBzdHI7XG4gIGZsYWdzID0gZmxhZ3MgfHwgJy1WLCAtLXZlcnNpb24nO1xuICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8ICdvdXRwdXQgdGhlIHZlcnNpb24gbnVtYmVyJztcbiAgdmFyIHZlcnNpb25PcHRpb24gPSBuZXcgT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbik7XG4gIHRoaXMuX3ZlcnNpb25PcHRpb25OYW1lID0gdmVyc2lvbk9wdGlvbi5sb25nLnN1YnN0cigyKSB8fCAndmVyc2lvbic7XG4gIHRoaXMub3B0aW9ucy5wdXNoKHZlcnNpb25PcHRpb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub24oJ29wdGlvbjonICsgdGhpcy5fdmVyc2lvbk9wdGlvbk5hbWUsIGZ1bmN0aW9uKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHN0ciArICdcXG4nKTtcbiAgICBzZWxmLl9leGl0KDAsICdjb21tYW5kZXIudmVyc2lvbicsIHN0cik7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiB0byBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NEZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1N0cmluZ3xDb21tYW5kfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN0ciwgYXJnc0Rlc2NyaXB0aW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XG4gIHRoaXMuX2Rlc2NyaXB0aW9uID0gc3RyO1xuICB0aGlzLl9hcmdzRGVzY3JpcHRpb24gPSBhcmdzRGVzY3JpcHRpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYW4gYWxpYXMgZm9yIHRoZSBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbihhbGlhcykge1xuICB2YXIgY29tbWFuZCA9IHRoaXM7XG4gIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW3RoaXMuY29tbWFuZHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNvbW1hbmQuX2FsaWFzO1xuXG4gIGlmIChhbGlhcyA9PT0gY29tbWFuZC5fbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdDb21tYW5kIGFsaWFzIGNhblxcJ3QgYmUgdGhlIHNhbWUgYXMgaXRzIG5hbWUnKTtcblxuICBjb21tYW5kLl9hbGlhcyA9IGFsaWFzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IC8gZ2V0IHRoZSBjb21tYW5kIHVzYWdlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RyXVxuICogQHJldHVybiB7U3RyaW5nfENvbW1hbmR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnVzYWdlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBhcmdzID0gdGhpcy5fYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGh1bWFuUmVhZGFibGVBcmdOYW1lKGFyZyk7XG4gIH0pO1xuXG4gIHZhciB1c2FnZSA9ICdbb3B0aW9uc10nICtcbiAgICAodGhpcy5jb21tYW5kcy5sZW5ndGggPyAnIFtjb21tYW5kXScgOiAnJykgK1xuICAgICh0aGlzLl9hcmdzLmxlbmd0aCA/ICcgJyArIGFyZ3Muam9pbignICcpIDogJycpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fdXNhZ2UgfHwgdXNhZ2U7XG4gIHRoaXMuX3VzYWdlID0gc3RyO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSBuYW1lIG9mIHRoZSBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtzdHJdXG4gKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX25hbWU7XG4gIHRoaXMuX25hbWUgPSBzdHI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gcHJlcGFyZWQgY29tbWFuZHMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5wcmVwYXJlQ29tbWFuZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29tbWFuZHMuZmlsdGVyKGZ1bmN0aW9uKGNtZCkge1xuICAgIHJldHVybiAhY21kLl9ub0hlbHA7XG4gIH0pLm1hcChmdW5jdGlvbihjbWQpIHtcbiAgICB2YXIgYXJncyA9IGNtZC5fYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gaHVtYW5SZWFkYWJsZUFyZ05hbWUoYXJnKTtcbiAgICB9KS5qb2luKCcgJyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgY21kLl9uYW1lICtcbiAgICAgICAgKGNtZC5fYWxpYXMgPyAnfCcgKyBjbWQuX2FsaWFzIDogJycpICtcbiAgICAgICAgKGNtZC5vcHRpb25zLmxlbmd0aCA/ICcgW29wdGlvbnNdJyA6ICcnKSArXG4gICAgICAgIChhcmdzID8gJyAnICsgYXJncyA6ICcnKSxcbiAgICAgIGNtZC5fZGVzY3JpcHRpb25cbiAgICBdO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXJnZXN0IGNvbW1hbmQgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmxhcmdlc3RDb21tYW5kTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb21tYW5kcyA9IHRoaXMucHJlcGFyZUNvbW1hbmRzKCk7XG4gIHJldHVybiBjb21tYW5kcy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBjb21tYW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgY29tbWFuZFswXS5sZW5ndGgpO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXJnZXN0IG9wdGlvbiBsZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubGFyZ2VzdE9wdGlvbkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3B0aW9ucyA9IFtdLnNsaWNlLmNhbGwodGhpcy5vcHRpb25zKTtcbiAgb3B0aW9ucy5wdXNoKHtcbiAgICBmbGFnczogdGhpcy5faGVscEZsYWdzXG4gIH0pO1xuXG4gIHJldHVybiBvcHRpb25zLnJlZHVjZShmdW5jdGlvbihtYXgsIG9wdGlvbikge1xuICAgIHJldHVybiBNYXRoLm1heChtYXgsIG9wdGlvbi5mbGFncy5sZW5ndGgpO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXJnZXN0IGFyZyBsZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubGFyZ2VzdEFyZ0xlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJncy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBhcmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBhcmcubmFtZS5sZW5ndGgpO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYWQgd2lkdGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUucGFkV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdpZHRoID0gdGhpcy5sYXJnZXN0T3B0aW9uTGVuZ3RoKCk7XG4gIGlmICh0aGlzLl9hcmdzRGVzY3JpcHRpb24gJiYgdGhpcy5fYXJncy5sZW5ndGgpIHtcbiAgICBpZiAodGhpcy5sYXJnZXN0QXJnTGVuZ3RoKCkgPiB3aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLmxhcmdlc3RBcmdMZW5ndGgoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb21tYW5kcyAmJiB0aGlzLmNvbW1hbmRzLmxlbmd0aCkge1xuICAgIGlmICh0aGlzLmxhcmdlc3RDb21tYW5kTGVuZ3RoKCkgPiB3aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLmxhcmdlc3RDb21tYW5kTGVuZ3RoKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpZHRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaGVscCBmb3Igb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5vcHRpb25IZWxwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3aWR0aCA9IHRoaXMucGFkV2lkdGgoKTtcblxuICB2YXIgY29sdW1ucyA9IHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMgfHwgODA7XG4gIHZhciBkZXNjcmlwdGlvbldpZHRoID0gY29sdW1ucyAtIHdpZHRoIC0gNDtcblxuICAvLyBBcHBlbmQgdGhlIGhlbHAgaW5mb3JtYXRpb25cbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXAoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgY29uc3QgZnVsbERlc2MgPSBvcHRpb24uZGVzY3JpcHRpb24gK1xuICAgICAgKCghb3B0aW9uLm5lZ2F0ZSAmJiBvcHRpb24uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpID8gJyAoZGVmYXVsdDogJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbi5kZWZhdWx0VmFsdWUpICsgJyknIDogJycpO1xuICAgIHJldHVybiBwYWQob3B0aW9uLmZsYWdzLCB3aWR0aCkgKyAnICAnICsgb3B0aW9uYWxXcmFwKGZ1bGxEZXNjLCBkZXNjcmlwdGlvbldpZHRoLCB3aWR0aCArIDIpO1xuICB9KS5jb25jYXQoW3BhZCh0aGlzLl9oZWxwRmxhZ3MsIHdpZHRoKSArICcgICcgKyBvcHRpb25hbFdyYXAodGhpcy5faGVscERlc2NyaXB0aW9uLCBkZXNjcmlwdGlvbldpZHRoLCB3aWR0aCArIDIpXSlcbiAgICAuam9pbignXFxuJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBjb21tYW5kIGhlbHAgZG9jdW1lbnRhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5jb21tYW5kSGVscCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY29tbWFuZHMubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgdmFyIGNvbW1hbmRzID0gdGhpcy5wcmVwYXJlQ29tbWFuZHMoKTtcbiAgdmFyIHdpZHRoID0gdGhpcy5wYWRXaWR0aCgpO1xuXG4gIHZhciBjb2x1bW5zID0gcHJvY2Vzcy5zdGRvdXQuY29sdW1ucyB8fCA4MDtcbiAgdmFyIGRlc2NyaXB0aW9uV2lkdGggPSBjb2x1bW5zIC0gd2lkdGggLSA0O1xuXG4gIHJldHVybiBbXG4gICAgJ0NvbW1hbmRzOicsXG4gICAgY29tbWFuZHMubWFwKGZ1bmN0aW9uKGNtZCkge1xuICAgICAgdmFyIGRlc2MgPSBjbWRbMV0gPyAnICAnICsgY21kWzFdIDogJyc7XG4gICAgICByZXR1cm4gKGRlc2MgPyBwYWQoY21kWzBdLCB3aWR0aCkgOiBjbWRbMF0pICsgb3B0aW9uYWxXcmFwKGRlc2MsIGRlc2NyaXB0aW9uV2lkdGgsIHdpZHRoICsgMik7XG4gICAgfSkuam9pbignXFxuJykucmVwbGFjZSgvXi9nbSwgJyAgJyksXG4gICAgJydcbiAgXS5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHByb2dyYW0gaGVscCBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmhlbHBJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGVzYyA9IFtdO1xuICBpZiAodGhpcy5fZGVzY3JpcHRpb24pIHtcbiAgICBkZXNjID0gW1xuICAgICAgdGhpcy5fZGVzY3JpcHRpb24sXG4gICAgICAnJ1xuICAgIF07XG5cbiAgICB2YXIgYXJnc0Rlc2NyaXB0aW9uID0gdGhpcy5fYXJnc0Rlc2NyaXB0aW9uO1xuICAgIGlmIChhcmdzRGVzY3JpcHRpb24gJiYgdGhpcy5fYXJncy5sZW5ndGgpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMucGFkV2lkdGgoKTtcbiAgICAgIHZhciBjb2x1bW5zID0gcHJvY2Vzcy5zdGRvdXQuY29sdW1ucyB8fCA4MDtcbiAgICAgIHZhciBkZXNjcmlwdGlvbldpZHRoID0gY29sdW1ucyAtIHdpZHRoIC0gNTtcbiAgICAgIGRlc2MucHVzaCgnQXJndW1lbnRzOicpO1xuICAgICAgZGVzYy5wdXNoKCcnKTtcbiAgICAgIHRoaXMuX2FyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgZGVzYy5wdXNoKCcgICcgKyBwYWQoYXJnLm5hbWUsIHdpZHRoKSArICcgICcgKyB3cmFwKGFyZ3NEZXNjcmlwdGlvblthcmcubmFtZV0sIGRlc2NyaXB0aW9uV2lkdGgsIHdpZHRoICsgNCkpO1xuICAgICAgfSk7XG4gICAgICBkZXNjLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbWROYW1lID0gdGhpcy5fbmFtZTtcbiAgaWYgKHRoaXMuX2FsaWFzKSB7XG4gICAgY21kTmFtZSA9IGNtZE5hbWUgKyAnfCcgKyB0aGlzLl9hbGlhcztcbiAgfVxuICB2YXIgcGFyZW50Q21kTmFtZXMgPSAnJztcbiAgZm9yICh2YXIgcGFyZW50Q21kID0gdGhpcy5wYXJlbnQ7IHBhcmVudENtZDsgcGFyZW50Q21kID0gcGFyZW50Q21kLnBhcmVudCkge1xuICAgIHBhcmVudENtZE5hbWVzID0gcGFyZW50Q21kLm5hbWUoKSArICcgJyArIHBhcmVudENtZE5hbWVzO1xuICB9XG4gIHZhciB1c2FnZSA9IFtcbiAgICAnVXNhZ2U6ICcgKyBwYXJlbnRDbWROYW1lcyArIGNtZE5hbWUgKyAnICcgKyB0aGlzLnVzYWdlKCksXG4gICAgJydcbiAgXTtcblxuICB2YXIgY21kcyA9IFtdO1xuICB2YXIgY29tbWFuZEhlbHAgPSB0aGlzLmNvbW1hbmRIZWxwKCk7XG4gIGlmIChjb21tYW5kSGVscCkgY21kcyA9IFtjb21tYW5kSGVscF07XG5cbiAgdmFyIG9wdGlvbnMgPSBbXG4gICAgJ09wdGlvbnM6JyxcbiAgICAnJyArIHRoaXMub3B0aW9uSGVscCgpLnJlcGxhY2UoL14vZ20sICcgICcpLFxuICAgICcnXG4gIF07XG5cbiAgcmV0dXJuIHVzYWdlXG4gICAgLmNvbmNhdChkZXNjKVxuICAgIC5jb25jYXQob3B0aW9ucylcbiAgICAuY29uY2F0KGNtZHMpXG4gICAgLmpvaW4oJ1xcbicpO1xufTtcblxuLyoqXG4gKiBPdXRwdXQgaGVscCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBjb21tYW5kLlxuICpcbiAqIFdoZW4gbGlzdGVuZXIocykgYXJlIGF2YWlsYWJsZSBmb3IgdGhlIGhlbHBMb25nRmxhZ1xuICogdGhvc2UgY2FsbGJhY2tzIGFyZSBpbnZva2VkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUub3V0cHV0SGVscCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICBjYiA9IGZ1bmN0aW9uKHBhc3N0aHJ1KSB7XG4gICAgICByZXR1cm4gcGFzc3RocnU7XG4gICAgfTtcbiAgfVxuICBjb25zdCBjYk91dHB1dCA9IGNiKHRoaXMuaGVscEluZm9ybWF0aW9uKCkpO1xuICBpZiAodHlwZW9mIGNiT3V0cHV0ICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKGNiT3V0cHV0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0SGVscCBjYWxsYmFjayBtdXN0IHJldHVybiBhIHN0cmluZyBvciBhIEJ1ZmZlcicpO1xuICB9XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNiT3V0cHV0KTtcbiAgdGhpcy5lbWl0KHRoaXMuX2hlbHBMb25nRmxhZyk7XG59O1xuXG4vKipcbiAqIFlvdSBjYW4gcGFzcyBpbiBmbGFncyBhbmQgYSBkZXNjcmlwdGlvbiB0byBvdmVycmlkZSB0aGUgaGVscFxuICogZmxhZ3MgYW5kIGhlbHAgZGVzY3JpcHRpb24gZm9yIHlvdXIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXVxuICogQHBhcmFtIHtTdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0NvbW1hbmR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmhlbHBPcHRpb24gPSBmdW5jdGlvbihmbGFncywgZGVzY3JpcHRpb24pIHtcbiAgdGhpcy5faGVscEZsYWdzID0gZmxhZ3MgfHwgdGhpcy5faGVscEZsYWdzO1xuICB0aGlzLl9oZWxwRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCB0aGlzLl9oZWxwRGVzY3JpcHRpb247XG5cbiAgdmFyIHNwbGl0RmxhZ3MgPSB0aGlzLl9oZWxwRmxhZ3Muc3BsaXQoL1sgLHxdKy8pO1xuXG4gIGlmIChzcGxpdEZsYWdzLmxlbmd0aCA+IDEpIHRoaXMuX2hlbHBTaG9ydEZsYWcgPSBzcGxpdEZsYWdzLnNoaWZ0KCk7XG5cbiAgdGhpcy5faGVscExvbmdGbGFnID0gc3BsaXRGbGFncy5zaGlmdCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdXRwdXQgaGVscCBpbmZvcm1hdGlvbiBhbmQgZXhpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmhlbHAgPSBmdW5jdGlvbihjYikge1xuICB0aGlzLm91dHB1dEhlbHAoY2IpO1xuICAvLyBleGl0Q29kZTogcHJlc2VydmluZyBvcmlnaW5hbCBiZWhhdmlvdXIgd2hpY2ggd2FzIGNhbGxpbmcgcHJvY2Vzcy5leGl0KClcbiAgLy8gbWVzc2FnZTogZG8gbm90IGhhdmUgYWxsIGRpc3BsYXllZCB0ZXh0IGF2YWlsYWJsZSBzbyBvbmx5IHBhc3NpbmcgcGxhY2Vob2xkZXIuXG4gIHRoaXMuX2V4aXQocHJvY2Vzcy5leGl0Q29kZSB8fCAwLCAnY29tbWFuZGVyLmhlbHAnLCAnKG91dHB1dEhlbHApJyk7XG59O1xuXG4vKipcbiAqIENhbWVsLWNhc2UgdGhlIGdpdmVuIGBmbGFnYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYW1lbGNhc2UoZmxhZykge1xuICByZXR1cm4gZmxhZy5zcGxpdCgnLScpLnJlZHVjZShmdW5jdGlvbihzdHIsIHdvcmQpIHtcbiAgICByZXR1cm4gc3RyICsgd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUGFkIGBzdHJgIHRvIGB3aWR0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYWQoc3RyLCB3aWR0aCkge1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgd2lkdGggLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0ciArIEFycmF5KGxlbiArIDEpLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggbGluZSBicmVha3MgYXQgdGhlIHNwZWNpZmllZCB3aWR0aCB3aGlsZSBicmVha2luZ1xuICogd29yZHMgYW5kIGluZGVudGluZyBldmVyeSBidXQgdGhlIGZpcnN0IGxpbmUgb24gdGhlIGxlZnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcChzdHIsIHdpZHRoLCBpbmRlbnQpIHtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnLnsxLCcgKyAod2lkdGggLSAxKSArICd9KFtcXFxcc1xcdTIwMEJdfCQpfFteXFxcXHNcXHUyMDBCXSs/KFtcXFxcc1xcdTIwMEJdfCQpJywgJ2cnKTtcbiAgdmFyIGxpbmVzID0gc3RyLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbiAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgaWYgKGxpbmUuc2xpY2UoLTEpID09PSAnXFxuJykge1xuICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuICgoaSA+IDAgJiYgaW5kZW50KSA/IEFycmF5KGluZGVudCArIDEpLmpvaW4oJyAnKSA6ICcnKSArIGxpbmUudHJpbVJpZ2h0KCk7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIE9wdGlvbmFsbHkgd3JhcCB0aGUgZ2l2ZW4gc3RyIHRvIGEgbWF4IHdpZHRoIG9mIHdpZHRoIGNoYXJhY3RlcnMgcGVyIGxpbmVcbiAqIHdoaWxlIGluZGVudGluZyB3aXRoIGluZGVudCBzcGFjZXMuIERvIG5vdCB3cmFwIGlmIGluc3VmZmljaWVudCB3aWR0aCBvclxuICogc3RyaW5nIGlzIG1hbnVhbGx5IGZvcm1hdHRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlbnRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvcHRpb25hbFdyYXAoc3RyLCB3aWR0aCwgaW5kZW50KSB7XG4gIC8vIERldGVjdCBtYW51YWxseSB3cmFwcGVkIGFuZCBpbmRlbnRlZCBzdHJpbmdzIGJ5IHNlYXJjaGluZyBmb3IgbGluZSBicmVha3NcbiAgLy8gZm9sbG93ZWQgYnkgbXVsdGlwbGUgc3BhY2VzL3RhYnMuXG4gIGlmIChzdHIubWF0Y2goL1tcXG5dXFxzKy8pKSByZXR1cm4gc3RyO1xuICAvLyBEbyBub3Qgd3JhcCB0byBuYXJyb3cgY29sdW1ucyAob3IgY2FuIGVuZCB1cCB3aXRoIGEgd29yZCBwZXIgbGluZSkuXG4gIGNvbnN0IG1pbldpZHRoID0gNDA7XG4gIGlmICh3aWR0aCA8IG1pbldpZHRoKSByZXR1cm4gc3RyO1xuXG4gIHJldHVybiB3cmFwKHN0ciwgd2lkdGgsIGluZGVudCk7XG59XG5cbi8qKlxuICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gaWYgaGVscCBmbGFncyBzcGVjaWZpZWRcbiAqXG4gKiBAcGFyYW0ge0NvbW1hbmR9IGNtZCAtIGNvbW1hbmQgdG8gb3V0cHV0IGhlbHAgZm9yXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zIC0gYXJyYXkgb2Ygb3B0aW9ucyB0byBzZWFyY2ggZm9yIC1oIG9yIC0taGVscFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3V0cHV0SGVscElmUmVxdWVzdGVkKGNtZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob3B0aW9uc1tpXSA9PT0gY21kLl9oZWxwTG9uZ0ZsYWcgfHwgb3B0aW9uc1tpXSA9PT0gY21kLl9oZWxwU2hvcnRGbGFnKSB7XG4gICAgICBjbWQub3V0cHV0SGVscCgpO1xuICAgICAgLy8gKERvIG5vdCBoYXZlIGFsbCBkaXNwbGF5ZWQgdGV4dCBhdmFpbGFibGUgc28gb25seSBwYXNzaW5nIHBsYWNlaG9sZGVyLilcbiAgICAgIGNtZC5fZXhpdCgwLCAnY29tbWFuZGVyLmhlbHBEaXNwbGF5ZWQnLCAnKG91dHB1dEhlbHApJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJndW1lbnQgYW5kIHJldHVybnMgaXRzIGh1bWFuIHJlYWRhYmxlIGVxdWl2YWxlbnQgZm9yIGhlbHAgdXNhZ2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaHVtYW5SZWFkYWJsZUFyZ05hbWUoYXJnKSB7XG4gIHZhciBuYW1lT3V0cHV0ID0gYXJnLm5hbWUgKyAoYXJnLnZhcmlhZGljID09PSB0cnVlID8gJy4uLicgOiAnJyk7XG5cbiAgcmV0dXJuIGFyZy5yZXF1aXJlZFxuICAgID8gJzwnICsgbmFtZU91dHB1dCArICc+J1xuICAgIDogJ1snICsgbmFtZU91dHB1dCArICddJztcbn1cblxuLy8gZm9yIHZlcnNpb25zIGJlZm9yZSBub2RlIHYwLjggd2hlbiB0aGVyZSB3ZXJlbid0IGBmcy5leGlzdHNTeW5jYFxuZnVuY3Rpb24gZXhpc3RzKGZpbGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoZnMuc3RhdFN5bmMoZmlsZSkuaXNGaWxlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFNjYW4gYXJndW1lbnRzIGFuZCBpbmNyZW1lbnQgcG9ydCBudW1iZXIgZm9yIGluc3BlY3QgY2FsbHMgKHRvIGF2b2lkIGNvbmZsaWN0cyB3aGVuIHNwYXduaW5nIG5ldyBjb21tYW5kKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzIC0gYXJyYXkgb2YgYXJndW1lbnRzIGZyb20gbm9kZS5leGVjQXJndlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW5jcmVtZW50Tm9kZUluc3BlY3RvclBvcnQoYXJncykge1xuICAvLyBUZXN0aW5nIGZvciB0aGVzZSBvcHRpb25zOlxuICAvLyAgLS1pbnNwZWN0Wz1baG9zdDpdcG9ydF1cbiAgLy8gIC0taW5zcGVjdC1icmtbPVtob3N0Ol1wb3J0XVxuICAvLyAgLS1pbnNwZWN0LXBvcnQ9W2hvc3Q6XXBvcnRcbiAgcmV0dXJuIGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICB2YXIgcmVzdWx0ID0gYXJnO1xuICAgIGlmIChhcmcuaW5kZXhPZignLS1pbnNwZWN0JykgPT09IDApIHtcbiAgICAgIHZhciBkZWJ1Z09wdGlvbjtcbiAgICAgIHZhciBkZWJ1Z0hvc3QgPSAnMTI3LjAuMC4xJztcbiAgICAgIHZhciBkZWJ1Z1BvcnQgPSAnOTIyOSc7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICBpZiAoKG1hdGNoID0gYXJnLm1hdGNoKC9eKC0taW5zcGVjdCgtYnJrKT8pJC8pKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBlLmcuIC0taW5zcGVjdFxuICAgICAgICBkZWJ1Z09wdGlvbiA9IG1hdGNoWzFdO1xuICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhcmcubWF0Y2goL14oLS1pbnNwZWN0KC1icmt8LXBvcnQpPyk9KFteOl0rKSQvKSkgIT09IG51bGwpIHtcbiAgICAgICAgZGVidWdPcHRpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QobWF0Y2hbM10pKSB7XG4gICAgICAgICAgLy8gZS5nLiAtLWluc3BlY3Q9MTIzNFxuICAgICAgICAgIGRlYnVnUG9ydCA9IG1hdGNoWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGUuZy4gLS1pbnNwZWN0PWxvY2FsaG9zdFxuICAgICAgICAgIGRlYnVnSG9zdCA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFyZy5tYXRjaCgvXigtLWluc3BlY3QoLWJya3wtcG9ydCk/KT0oW146XSspOihcXGQrKSQvKSkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZS5nLiAtLWluc3BlY3Q9bG9jYWxob3N0OjEyMzRcbiAgICAgICAgZGVidWdPcHRpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgZGVidWdIb3N0ID0gbWF0Y2hbM107XG4gICAgICAgIGRlYnVnUG9ydCA9IG1hdGNoWzRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWdPcHRpb24gJiYgZGVidWdQb3J0ICE9PSAnMCcpIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7ZGVidWdPcHRpb259PSR7ZGVidWdIb3N0fToke3BhcnNlSW50KGRlYnVnUG9ydCkgKyAxfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/commander/index.js\n");

/***/ }),

/***/ "./src/Cmd.class.js":
/*!**************************!*\
  !*** ./src/Cmd.class.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Cmd {\r\n  constructor(program) {\r\n    this.cpOption = program.classpath;\r\n    this.className = program.args[0];\r\n    this.args = program.args.slice(1);\r\n    this.version = program.version();\r\n  }\r\n  printClasspath() {\r\n    console.log(`classpath:${this.cpOption} class:${this.className} args:${this.args}`);\r\n  }\r\n  printArgs() {\r\n    console.log(`[${this.args.join(' ')}]`);\r\n  }\r\n}\r\nmodule.exports = Cmd;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ21kLmNsYXNzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL0NtZC5jbGFzcy5qcz8wOTM1Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIENtZCB7XHJcbiAgY29uc3RydWN0b3IocHJvZ3JhbSkge1xyXG4gICAgdGhpcy5jcE9wdGlvbiA9IHByb2dyYW0uY2xhc3NwYXRoO1xyXG4gICAgdGhpcy5jbGFzc05hbWUgPSBwcm9ncmFtLmFyZ3NbMF07XHJcbiAgICB0aGlzLmFyZ3MgPSBwcm9ncmFtLmFyZ3Muc2xpY2UoMSk7XHJcbiAgICB0aGlzLnZlcnNpb24gPSBwcm9ncmFtLnZlcnNpb24oKTtcclxuICB9XHJcbiAgcHJpbnRDbGFzc3BhdGgoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgY2xhc3NwYXRoOiR7dGhpcy5jcE9wdGlvbn0gY2xhc3M6JHt0aGlzLmNsYXNzTmFtZX0gYXJnczoke3RoaXMuYXJnc31gKTtcclxuICB9XHJcbiAgcHJpbnRBcmdzKCkge1xyXG4gICAgY29uc29sZS5sb2coYFske3RoaXMuYXJncy5qb2luKCcgJyl9XWApO1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IENtZDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Cmd.class.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const program = __webpack_require__(/*! commander */ \"./node_modules/commander/index.js\"),\r\n  Cmd = __webpack_require__(/*! ./Cmd.class */ \"./src/Cmd.class.js\");\r\nlet listOfInputArgs = [\"node\", \"index.js\", '--classpath', 'foo/bar', 'MyApp', 'arg1', 'arg2'];\r\n\r\nfunction start_JVM(cmd) {\r\n  cmd.printClasspath();\r\n}\r\n\r\nfunction main() {\r\n  program\r\n    .version(\"0.0.1\")\r\n    .usage(\"[options] class [args...]\")\r\n    .option(\"-c, --classpath [value]\", \"Class Path\")\r\n    .parse(process.argv);\r\n\r\n  if (program.classpath) {\r\n    let cmd = new Cmd(program);\r\n    start_JVM(cmd);\r\n  }\r\n}\r\nmain();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcm9ncmFtID0gcmVxdWlyZShcImNvbW1hbmRlclwiKSxcclxuICBDbWQgPSByZXF1aXJlKFwiLi9DbWQuY2xhc3NcIik7XHJcbmxldCBsaXN0T2ZJbnB1dEFyZ3MgPSBbXCJub2RlXCIsIFwiaW5kZXguanNcIiwgJy0tY2xhc3NwYXRoJywgJ2Zvby9iYXInLCAnTXlBcHAnLCAnYXJnMScsICdhcmcyJ107XHJcblxyXG5mdW5jdGlvbiBzdGFydF9KVk0oY21kKSB7XHJcbiAgY21kLnByaW50Q2xhc3NwYXRoKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgcHJvZ3JhbVxyXG4gICAgLnZlcnNpb24oXCIwLjAuMVwiKVxyXG4gICAgLnVzYWdlKFwiW29wdGlvbnNdIGNsYXNzIFthcmdzLi4uXVwiKVxyXG4gICAgLm9wdGlvbihcIi1jLCAtLWNsYXNzcGF0aCBbdmFsdWVdXCIsIFwiQ2xhc3MgUGF0aFwiKVxyXG4gICAgLnBhcnNlKHByb2Nlc3MuYXJndik7XHJcblxyXG4gIGlmIChwcm9ncmFtLmNsYXNzcGF0aCkge1xyXG4gICAgbGV0IGNtZCA9IG5ldyBDbWQocHJvZ3JhbSk7XHJcbiAgICBzdGFydF9KVk0oY21kKTtcclxuICB9XHJcbn1cclxubWFpbigpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ })

/******/ });